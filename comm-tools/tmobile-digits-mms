#!/usr/bin/perl
use strict;
use warnings;
use Time::HiRes qw(time);
use JSON qw(decode_json encode_json);
use Try::Tiny;

my $HAR_EXTRACTOR = "$ENV{HOME}/.local/bin/har-extractor";
my $SMS_DB_IMPORTER = "$ENV{HOME}/Code/sx/comm-tools/sms_db_importer.py";
my $RESTORE_COMM = "$ENV{HOME}/Code/sx/restore-comm";

my $MY_NUMBER_FILE = "$ENV{HOME}/Code/sx/backup/my_number";
my $MMS_REPO = "$ENV{HOME}/Code/sx/backup/backup-mms/repo";
my $MMS_PARTS_REPO = "$ENV{HOME}/Code/sx/backup/backup-mms/parts-repo";

my $HAR_FILE_BACKUP_DIR = "$ENV{HOME}/Code/sx/backup/backup-mms/tmobile-digits-har-files";

my $ADD_COMM_TO_REPO_CMD = "$ENV{HOME}/Code/sx/comm-tools/add-comm-to-repo.pl";

my $PICNAME_CMD = "picname";

my $INSTRUCTIONS = ""
  . "  HAR_FILE messages get written to mms repo + parts-repo\n"
  . "    $MMS_REPO\n"
  . "    $MMS_PARTS_REPO\n"
  . "  some are VERY LIKELY DUPES\n"
  . "  commit the ones you want and remove the rest (maybe git clean -f -d)\n"
  . "  ensure mms dir AND mms parts dir are both correct\n"
  . "  to test consistency, run: $RESTORE_COMM --dry-run\n"
;

my $USAGE = "Usage:
  $0 -h|--help
    show this message

  $0 [OPTS] -l | --latest
    same as: $0 [OPTS] 0

  $0 [OPTS] BACKUP_INDEX
    -run: $PICNAME_CMD -a --quiet $HAR_FILE_BACKUP_DIR/*.har
    -select <INDEXED_HAR_FILE> for <BACKUP_INDEX> (0-indexed, newest-first, by mtime)
      -list <INDEXED_HAR_FILE>s from $HAR_FILE_BACKUP_DIR
      -order <INDEXED_HAR_FILE>s by mtime, newest-first
      -assign an <INDEX> to each, starting with 0
      -if <BACKUP_INDEX> is non-negative:
        -select <INDEXED_HAR_FILE> with: <BACKUP_INDEX> = <INDEX>
        -e.g.: 0 is the newest, 1 is the second-newest
      -if <BACKUP_INDEX> is negative:
        -count the number of <INDEXED_HAR_FILE>s as <BACKUP_COUNT>
        -select <INDEXED_HAR_FILE> with: <BACKUP_INDEX> = <INDEX> - <BACKUP_COUNT>
        -e.g.: -1 is the oldest, -2 is the second-oldest
    -same as: $0 <INDEXED_HAR_FILE>

  $0 [OPTS] HAR_FILE
    $INSTRUCTIONS

  --sms
    skip MMS parsing, and parse SMS instead
    format and output to SMS_CSV_FILE, and add to repo with:
    $ADD_COMM_TO_REPO_CMD

  --offset-hours=OFFSET_HOURS
    adjust msg info date and dateSent by positive or negative hours
    OFFSET_HOURS must be an integer
      same as: --offset-millis=\$((\$OFFSET_HOURS * 60 * 60 * 1000))

  --offset-millis=OFFSET_MILLIS
    adjust msg info date and dateSent by positive or negative milliseconds
    OFFSET_MILLIS must be an integer
";

sub handleMMS($$$$);
sub extractHarFile($);
sub getBackupHarFile($);
sub cleanNumber($);
sub escapeStr($);
sub parseMMSFile($);
sub parseSMSFile($);
sub formatSMS($);
sub decodeBase64($);
sub mtime($);
sub run(@);
sub nowMillis();

sub main(@){
  my $harFile;
  my $offsetMillis = 0;
  my $smsMode = 0;
  while(@_ > 0){
    my $arg = shift;
    if($arg =~ /^(-h|--help)$/){
      print $USAGE;
      exit 0;
    }elsif($arg =~ /^(-l|--latest)$/i){
      $harFile = getBackupHarFile(0);
    }elsif($arg =~ /^(\d+|-\d+)$/){
      $harFile = getBackupHarFile($1);
    }elsif(-f $arg and $arg =~ /\.har$/i){
      $harFile = $arg;
    }elsif($arg =~ /^--offset-hours=(-?\d+)$/){
      $offsetMillis = $1*60*60*1000;
    }elsif($arg =~ /^--offset-millis=(-?\d+)$/){
      $offsetMillis = $1;
    }elsif($arg =~ /^--sms$/){
      $smsMode = 1;
    }else{
      die "$USAGE\nERROR: unknown arg $arg\n";
    }
  }

  die "$USAGE\nERROR: missing HAR_FILE\n" if not defined $harFile;

  my $myNum = `cat $MY_NUMBER_FILE`;
  chomp $myNum;
  $myNum = cleanNumber($myNum);
  if($myNum !~ /^\d{10}$/){
    die "ERROR: could not parse $MY_NUMBER_FILE\n";
  }

  my $outDir = extractHarFile($harFile);

  if($smsMode){
    my @smsFiles = sort grep {/^(.*\/)?search(\.\d+)?$/} `find $outDir -name 'search*' -type f`;
    chomp $_ foreach @smsFiles;
    my @sms;
    for my $smsFile(@smsFiles){
      @sms = (@sms, parseSMSFile($smsFile));
    }

    #ignore empty SMS
    @sms = grep {$$_{body} ne '""'} @sms;

    print "\n\n\n";
    my $smsCsvFile = "/tmp/tmobile-digits-sms-" . nowMillis() . ".sms";
    open FH, "> $smsCsvFile" or die "ERROR: could not write $smsCsvFile\n$!\n";
    for my $sms(@sms){
      my $fmt = formatSMS($sms);
      print FH $fmt;
    }
    close FH;
    my $count = @sms;
    print "\nwrote $count SMS to $smsCsvFile\n";
    print "\n\n\n";
    run $ADD_COMM_TO_REPO_CMD,
      "--sms", $smsCsvFile,
      "--allow-old",
      "--dupe=fuzzy",
      "--fuzzy-whitespace-dupes",
      "--fuzzy-dupe-millis=" . 4 * 60 * 60 * 1000, #4 hours
      "--verbose",
    ;
    exit 0;
  }

  my @mmsFiles = sort `find $outDir -iregex '.*/objects/.*' -type f`;
  chomp $_ foreach @mmsFiles;
  system "dos2unix $_ 2>/dev/null" foreach @mmsFiles;

  for my $file(@mmsFiles){
    my $mms = parseMMSFile($file);
    handleMMS($myNum, $offsetMillis, $file, $mms);
  }

  print "\n\nWROTE " . (0+@mmsFiles) . " MMS MESSAGES\n";
  print $INSTRUCTIONS;
}

sub handleMMS($$$$){
    my ($myNum, $offsetMillis, $srcFile, $mms) = @_;
    my $msgDateMillis = $$mms{dtmMillis} + $offsetMillis;

    my $dir;
    my $otherNum;
    if($$mms{from} eq $myNum){
      $dir = "OUT";
      $otherNum = $$mms{to};
    }elsif($$mms{to} eq $myNum){
      $dir = "INC";
      $otherNum = $$mms{from};
    }else{
      #MMS sent to other person and 'forwarded' to me
      $dir = "INC";
      $otherNum = $$mms{from};
    }

    if($otherNum !~ /^\d{10}$/){
      print "\n\n\n\n\n\n";
      print "WARNING: could not parse MMS phone number \"$otherNum\" for $srcFile\n";
      next;
    }

    my $nowMillis = nowMillis();
    my $counter = "00000";
    my $mmsPartsDir;
    do{
      $mmsPartsDir = "$MMS_PARTS_REPO/msg-${msgDateMillis}-$counter";
      $counter++;
    }while(-e $mmsPartsDir);

    run "mkdir", "-p", $mmsPartsDir;

    my @attFileList;
    for my $att(@{$$mms{atts}}){
      my $attFile = "$mmsPartsDir/$$att{attName}";
      push @attFileList, $attFile;
      open FH, "> $attFile" or die "ERROR: could not write $attFile\n$!\n";
      print FH $$att{attContents};
      close FH;
    }
    if(defined $$mms{body}){
      my $textAttFile = "$mmsPartsDir/$$mms{textAttName}";
      push @attFileList, $textAttFile;
      open FH, "> $textAttFile" or die "ERROR: could not write $textAttFile\n$!\n";
      print FH $$mms{body};
      close FH;
    }
    my $body = $$mms{body};
    $body = "" if not defined $body;

    my $subject = $$mms{subject};

    my $subjectFmt = escapeStr($subject);
    my $bodyFmt = escapeStr($body);

    open CMD, "-|", $SMS_DB_IMPORTER, "mms-hash", $subject, $body, @attFileList;
    my $checksum = join '', <CMD>;
    close CMD;
    chomp $checksum;

    if($checksum !~ /^[0-9a-f]{32}$/){
      die "ERROR: invalid MMS hash from $SMS_DB_IMPORTER for MMS file\n$srcFile\n";
    }

    my $mmsRepoDir = "$MMS_REPO/${msgDateMillis}_${otherNum}_${dir}_${checksum}";
    run "mkdir", "-p", $mmsRepoDir;

    for my $attFile(@attFileList){
      run "cp", "-a", $attFile, "$mmsRepoDir/";
    }

    my $info = ""
      . "from=$$mms{from}\n"
      . "to=$$mms{to}\n"
      . "dir=$dir\n"
      . "date=$msgDateMillis\n"
      . "date_sent=$msgDateMillis\n"
      . "subject=\"$subjectFmt\"\n"
      . "body=\"$bodyFmt\"\n"
      ;
    for my $attFile(@attFileList){
      my $att = $attFile;
      $att =~ s/^.*\///;
      $info .= "att=$att\n";
    }
    $info .= "checksum=$checksum\n";

    my $infoFile = "$mmsRepoDir/info";
    open FH, "> $infoFile" or die "ERROR: could not write $infoFile\n$!\n";
    print FH $info;
    close FH;
}

sub extractHarFile($){
  my ($harFile) = @_;
  if(not -x $HAR_EXTRACTOR){
    run "pip", "install", "har-extractor";
  }
  if(not -x $HAR_EXTRACTOR){
    die "ERROR: could not find $HAR_EXTRACTOR\n";
  }

  my $nowMillis = nowMillis();
  my $outDir = "/tmp/tmobile-digits-har-$nowMillis/";

  run $HAR_EXTRACTOR, $harFile, "-o", $outDir;

  return $outDir;
}

sub getBackupHarFile($){
  my ($index) = @_;

  run "$PICNAME_CMD -a --quiet $HAR_FILE_BACKUP_DIR/*.har";

  my @harFiles = grep {-f $_} glob "$HAR_FILE_BACKUP_DIR/*.har";
  if(@harFiles == 0){
    die "ERROR: no har files found in $HAR_FILE_BACKUP_DIR\n";
  }
  my %mtimes = map {$_ => mtime $_} @harFiles;

  @harFiles = sort {$mtimes{$b} <=> $mtimes{$a}} @harFiles;

  my $harFile = $harFiles[$index];
  if(not defined $harFile or not -f $harFile){
    die "ERROR: INDEXED_HAR_FILE not found for BACKUP_INDEX=$index\n";
  }
  return $harFile;
}

sub cleanNumber($){
  my ($number) = @_;
  $number = "" if not defined $number;
  $number = $1 if $number =~ /^sip:([+0-9]+)@.*$/;
  $number =~ s/[^+0-9]//g;
  $number = $1 if $number =~ /^\+?1(\d{10})$/;
  return $number
}
sub escapeStr($){
  my ($str) = @_;
  $str =~ s/&/&amp;/g;
  $str =~ s/\\/&backslash;/g;
  $str =~ s/\n/\\n/g;
  $str =~ s/\r/\\r/g;
  $str =~ s/"/\\"/g;
  $str =~ s/&backslash;/\\\\/g;
  $str =~ s/&amp;/&/g;
  return $str;
}


sub parseMMSFile($){
  my ($mmsFile) = @_;
  my @lines = `cat "$mmsFile"`;

  my $mms = {
    from        => undef,
    to          => undef,
    dtm         => undef,
    body        => undef,
    subject     => "NoSubject",
    textAttName => undef,
    atts        => [],
  };

  my @parts;
  my $curPart = undef;
  for my $line(@lines){
    if($line =~ /^--/){
      $curPart = [];
      push @parts, $curPart;
    }elsif(not defined $curPart){
      if($line =~ /^From:\s*(.+)$/){
        $$mms{from} = cleanNumber($1);
      }elsif($line =~ /^To:\s*(.+)$/){
        $$mms{to} = cleanNumber($1);
      }elsif($line =~ /^DateTime:\s*(.+)$/){
        $$mms{dtm} = $1;
      }
    }else{
      push @$curPart, $line;
    }
  }

  for my $part(@parts){
    my $text = join "", @$part;
    next if $text eq "";
    if($text =~ /^(.*?)\n\n(.*)$/s){
      my ($partHdr, $partBody) = ($1, $2);
      if($partHdr =~ /base64/i){
        $partBody = decodeBase64($partBody);
      }
      if($partHdr =~ /text/i){
        die "ERROR: duplicate text parts for $mmsFile\n" if defined $$mms{body};
        $$mms{body} = $partBody;
        if($partHdr =~ /Content-Location:(.+)/){
          $$mms{textAttName} = $1;
        }
      }else{
        my $attName = undef;
        if($partHdr =~ /Content-Location:(.+)/){
          $attName = $1;
        }elsif($partHdr =~ /Content-Type:\S*;Name="([^"]+)"/){
          $attName = $1;
        }
        my $att = {
          attName     => $attName,
          attContents => $partBody,
        };
        push @{$$mms{atts}}, $att;
      }
    }else{
      die "ERROR: malformed MMS part:$text\nin mms file:\n$mmsFile\n";
    }
  }

  my $dtmFmt = `date --date='$$mms{dtm}' '+%Y%m%d_%H%M%S'`;
  chomp $dtmFmt;
  my $epoch = `date --date='$$mms{dtm}' +%s`;
  chomp $epoch;

  $$mms{dtmFmt} = $dtmFmt;
  $$mms{dtmEpoch} = $epoch;
  $$mms{dtmMillis} = "${epoch}000";

  if(defined $$mms{body} and not defined $$mms{textAttName}){
    $$mms{textAttName} = "text";
  }
  for my $att(@{$$mms{atts}}){
    if(not defined $$att{attName}){
      die "ERROR: missing file name for att part in mms file\n$mmsFile\n";
    }
    if(not defined $$att{attContents}){
      die "ERROR: could not parse file contents for att $$att{attName} in mms file\n$mmsFile\n";
    }
  }

  return $mms;
}

sub parseSMSFile($){
  my ($smsFile) = @_;
  my $json = `cat '$smsFile'`;
  my @objects;
  try{
    my $mainObj = decode_json($json);
    @objects = @{$$mainObj{objectList}{object}};
  }catch{
    warn "\n\nWARNING: could not parse SMS JSON file $smsFile\n$_\n";
    return undef;
  };
  my @smsMsgs;
  for my $obj(@objects){
    try{
      my $attList = $$obj{attributes}{attribute};
      my $smsAtts = {};
      for my $att(@$attList){
        my $name = $$att{name};
        my $values = $$att{value};
        my $value = @$values == 1 ? $$values[0] : undef;
        die "ERROR: dupe att $name\n" if defined $$smsAtts{$name};
        $$smsAtts{$name} = $value;
      }
      my $dateMillis = `date --date="$$smsAtts{date}" +%s%3N`;
      chomp $dateMillis;
      die "ERROR: could not parse date $$smsAtts{date}\n" if $dateMillis !~ /^\d+$/;

      my $dateS = int($dateMillis / 1000.0 + 0.5);
      my $dateFmt = `date --date=\@$dateS '+%Y-%m-%d %H:%M:%S'`;
      chomp $dateFmt;
      my $dir;
      if($$smsAtts{Direction} =~ /^In$/i){
        $dir = "INC";
      }elsif($$smsAtts{Direction} =~ /^Out$/i){
        $dir = "OUT";
      }else{
        die "ERROR: invalid Direction $$smsAtts{Direction}\n";
      }
      my $body = $$smsAtts{textcontent};
      $body = "" if not defined $body;

      #remove trailing whitespace
      $body =~ s/\s+$//g;

      #format for CSV column
      $body =~ s/\\/\\\\/g;
      $body =~ s/\n/\\n/g;
      $body =~ s/"/\\"/g;
      $body = "\"$body\"";

      my $smsMsg = {
        date     => $dateMillis,
        dateSent => $dateMillis,
        dateFmt  => $dateFmt,
        dir      => $dir,
        from     => cleanNumber($$smsAtts{from}),
        to       => cleanNumber($$smsAtts{to}),
        body     => $body,
      };

      push @smsMsgs, $smsMsg;
    }catch{
      my $failedSMS = encode_json($obj);
      warn "\n\nWARNING: could not parse SMS in $smsFile\n$failedSMS\n$_\n";
      return undef;
    };
  }

  return @smsMsgs;
}

sub formatSMS($){
  my ($smsMsg) = @_;
  my $fmt = "";
  if($$smsMsg{dir} eq "INC"){
    $fmt .= $$smsMsg{from};
  }elsif($$smsMsg{dir} eq "OUT"){
    $fmt .= $$smsMsg{to};
  }else{
    die "ERROR: invalid direction $$smsMsg{dir}\n";
  }

  $fmt .= ",$$smsMsg{date}";
  $fmt .= ",$$smsMsg{dateSent}";
  $fmt .= ",S";
  $fmt .= ",$$smsMsg{dir}";
  $fmt .= ",$$smsMsg{dateFmt}";
  $fmt .= ",$$smsMsg{body}";
  $fmt .= "\n";
  return $fmt;
}

sub decodeBase64($){
  my ($str) = @_;
  my $nowMillis = nowMillis();
  my $tmpFile = "/tmp/tmobile-digits-base64-$nowMillis";
  open FH, "> $tmpFile" or die "ERROR: could not write $tmpFile\n$!\n";
  print FH $str;
  close FH;
  system "dos2unix", "-q", $tmpFile;

  my $out = `base64 -d $tmpFile`;
  if($? != 0){
    die "ERROR: base64 decode failed for:\n$str\n";
  }

  return $out;
}

sub mtime($){
  my @stat = stat $_[0];
  return $stat[9];
}

sub run(@){
  print "@_\n";
  system @_;
}

sub nowMillis(){
  return int(time*1000.0 + 0.5);
}

&main(@ARGV);
