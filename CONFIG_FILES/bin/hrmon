#!/usr/bin/perl
use strict;
use warnings;
use Date::Parse qw(str2time);
use File::Basename qw(basename);

sub getLastLogFile();
sub getLastHeartrateLogEntry();
sub formatRelativeTime($);
sub readProc(@);
sub stopHrmon();
sub run(@);

my $MAC_H10 = 'A0:9E:1A:D0:56:2E';
my $MAC_H7 = '00:22:D0:44:94:5A';

my $MAC = $MAC_H10;

my $BLE_HRL_EXEC = "BLEHeartRateLogger.py";

my $LOG_DIR = "$ENV{HOME}/.cache/logs/hrmon";

my $EXEC = basename $0;

my $USAGE = "Usage:
  $EXEC -h | --help
    show this message

  $EXEC
  $EXEC --screen-daemon | --ensure-attach | ensure-attach
    ensure screen-daemon is running and attach to it
      -run: 'screen-daemon hrmon --ensure-attach'

  $EXEC --run | run
    kill any $BLE_HRL_EXEC procs and run $BLE_HRL_EXEC
      -run: pkill -f BLEHeartRateLogger.py
      -run: $BLE_HRL_EXEC -b -v -m $MAC

  $EXEC --start | start
    run --stop, and then start screen-daemon
      -stop as in: `$EXEC --stop`
      -run: screen-daemon hrmon --start

  $EXEC --stop | stop
    stop screen-daemon and kill any other $BLE_HRL_EXEC procs
      -run: screen-daemon hrmon --stop
      -run: pkill -f BLEHeartRateLogger.py

  $EXEC --status | status
    print 'on' or 'off' if screen daemon is running
      -get <STATUS> as 'on' or 'off'
        -run: screen-daemon hrmon --status
      -print '<STATUS>'

  $EXEC --last | last
    print the last 'Heart rate' line of the last log file (decompress gz/bz2/xz if necessary)
      -fetch latest log file as in: `ls $LOG_DIR/*.log* | sort | tail -1`
      -if compressed, decompress in memory
      -find the last line, if any, that matches:
        '<DATETIME_FMT>  Heart rate: <HEARTRATE>'
          where <DATETIME_FMT> is the date/time formatted 'YYYY-mm-dd HH:MM:SS,NNN'
            and <HEARTRATE> is a non-negative integer
      -if no line matches:
        -print 'none'
      -otherwise:
        -parse the DATETIME_FMT, compare to current time and get ELAPSED_TIME_S
        -format ELAPSED_TIME_S as value ELAPSED_TIME_FMT with optional units days/hours/minutes
                      '#s'
                   '#m##s'
                '#h##m##s'
             '#d##h##m##s'
        -calculate DIRECTION
          -if DATETIME_FMT is in the past (should always be the case): 'ago'
          -otherwise: 'in the future'
        -print '<HEARTRATE_FMT> (<ELAPSED_TIME_FMT> <DIRECTION>)'
          e.g.: 90 (3d04h22m3s ago)

  $EXEC --rotate-logs | rotate-logs | logs
    stop monitoring, compress all logs, and restart if was running
      -get PREV_STATUS as in: STATUS=`$EXEC --status`
      -run: $EXEC --stop
      -run: bzip2 $LOG_DIR/*.log
      -if \$PREV_STATUS = 'on':
        run: $EXEC --start
";

my $CMD_ENSURE_ATTACH = "ensure-attach";
my $CMD_RUN = "run";
my $CMD_START = "start";
my $CMD_STOP = "stop";
my $CMD_STATUS = "status";
my $CMD_LAST = "last";
my $CMD_ROTATE_LOGS = "rotate-logs";

sub main(@){
  my $cmd = $CMD_ENSURE_ATTACH;
  while(@_ > 0){
    my $arg = shift @_;
    if($arg =~ /^(-h|--help)$/){
      print $USAGE;
      exit 0;
    }elsif($arg =~ /^(--screen-daemon|--ensure-attach|ensure-attach)$/){
      $cmd = $CMD_ENSURE_ATTACH;
    }elsif($arg =~ /^(--run|run)$/){
      $cmd = $CMD_RUN;
    }elsif($arg =~ /^(--start|start)$/){
      $cmd = $CMD_START;
    }elsif($arg =~ /^(--stop|stop)$/){
      $cmd = $CMD_STOP;
    }elsif($arg =~ /^(--status|status)$/){
      $cmd = $CMD_STATUS;
    }elsif($arg =~ /^(--last|last)$/){
      $cmd = $CMD_LAST;
    }elsif($arg =~ /^(--rotate-logs|rotate-logs|logs)$/){
      $cmd = $CMD_ROTATE_LOGS;
    }else{
      die "$USAGE\nERROR: unknown arg $arg\n";
    }
  }

  if($cmd eq $CMD_ENSURE_ATTACH){
    exec "screen-daemon", "hrmon", "--ensure-attach";
  }elsif($cmd eq $CMD_RUN){
    exec $BLE_HRL_EXEC,
      "-b",            #display battery
      "-v",            #display rr
      "-H", "0x0010",  #use handle 0x0010 to read BLE hr values
      "-C", "0x0011",  #use handle 0x0011 to request BLE hr values
      "-t", "public",  #pass '-t public' to gatttool instead of '-t random'
      "-m", $MAC,      #device bt mac
    ;
  }elsif($cmd eq $CMD_START){
    stopHrmon();
    run "screen-daemon", "hrmon", "--start";
  }elsif($cmd eq $CMD_STOP){
    stopHrmon();
  }elsif($cmd eq $CMD_STATUS){
    run "screen-daemon", "hrmon", "--status";
  }elsif($cmd eq $CMD_LAST){
    my ($hr, $epoch) = getLastHeartrateLogEntry();
    if(not defined $hr){
      print "none\n";
    }else{
      print "$hr (" . formatRelativeTime($epoch) . ")\n";
    }
  }elsif($cmd eq $CMD_ROTATE_LOGS){
    system "mkdir", "-p", $LOG_DIR;
    my @logFiles = sort glob "$LOG_DIR/*.log";
    if(@logFiles == 0){
      print "skipping, no uncompressed log files available in $LOG_DIR\n";
      exit 0;
    }

    my $status = `screen-daemon hrmon --status`;
    stopHrmon();
    run "bzip2", @logFiles;
    if(-l "$LOG_DIR/latest"){
      #remove latest symlink if present, since compressing breaks it
      run "rm", "$LOG_DIR/latest";
    }

    if($status =~ /on/){
      stopHrmon();
      print "re-starting screen-daemon\n";
      run "screen-daemon", "hrmon", "--start";
    }
  }else{
    die "ERROR: unknown cmd $cmd\n"
  }
}

sub getLastLogFile(){
  my @logFiles = sort glob "$LOG_DIR/*.log*";
  die "ERROR: no log files available in $LOG_DIR\n" if @logFiles == 0;
  my $lastLogFile = $logFiles[-1];
  return $lastLogFile;
}

sub getLastHeartrateLogEntry(){
  my $logFile = getLastLogFile();
  my @cmd;
  if($logFile =~ /\.log$/){
    @cmd = ("sh", "-c", "grep 'Heart rate' '$logFile' | tail -1");
  }elsif($logFile =~ /\.log\.gz$/){
    @cmd = ("sh", "-c", "zgrep 'Heart rate' '$logFile' | tail -1");
  }elsif($logFile =~ /\.log\.xz$/){
    @cmd = ("sh", "-c", "xz -d -c '$logFile' | grep 'Heart rate' | tail -1");
  }elsif($logFile =~ /\.log\.bz2$/){
    @cmd = ("sh", "-c", "bzip2 -d -c '$logFile' | grep 'Heart rate' | tail -1");
  }else{
    die "ERROR: unrecognized log file format '$logFile'\n";
  }

  my $out = readProc @cmd;
  if($out =~ /^\s*$/){
    return (undef, undef);
  }
  if($out !~ /^(\d\d\d\d-\d\d-\d\d) (\d\d:\d\d:\d\d),(\d\d\d)\s+Heart rate:\s*(\d+)$/){
    die "ERROR: invalid log line format in $logFile:\n$out\n";
  }
  my ($ymd, $hms, $millis, $heartrate) = ($1, $2, $3, $4);
  my $epoch = str2time "${ymd}T${hms}";
  return ($heartrate, $epoch);
}

sub formatRelativeTime($){
  my ($epoch) = @_;
  my $diff = time - $epoch;
  my $isNegative = $diff < 0;
  $diff = 0-$diff if $isNegative;

  my $s = int($diff % 60);
  my $m = int($diff / 60 % 60);
  my $h = int($diff / 60 / 60 % 24);
  my $d = int($diff / 60 / 60 / 24);

  my $fmt;
  if($d > 0){
    $fmt = sprintf "%dd%02dh%02dm%02ds", $d, $h, $m, $s;
  }elsif($h > 0){
    $fmt = sprintf "%dh%02dm%02ds", $h, $m, $s;
  }elsif($m > 0){
    $fmt = sprintf "%dm%02ds", $m, $s;
  }else{
    $fmt = sprintf "%dds", $m, $s;
  }

  my $direction = $isNegative ? "in the future" : "ago";
  return "$fmt $direction";
}

sub readProc(@){
  my @cmd = @_;
  open my $cmdFH, "-|", @cmd or die "ERROR: could not run @cmd\n$!\n";
  my @lines = <$cmdFH>;
  close $cmdFH;
  if(wantarray){
    return @lines;
  }else{
    return join '', @lines;
  }
}

sub stopHrmon(){
  run "screen-daemon", "hrmon", "--stop";
  run "pkill", "-f", $BLE_HRL_EXEC;
}

sub run(@){
  print "@_\n";
  system @_;
}

&main(@ARGV);
