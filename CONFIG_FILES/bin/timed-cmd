#!/usr/bin/perl
use strict;
use warnings;
use File::Basename qw(basename);
use List::Util qw(max);
use Time::HiRes qw(time);

sub readConf($);
sub addConfEntry($);
sub getAllEventCookies();
sub getTimedCmdEventCookies($);
sub getTimedCmdEventInfo($);
sub getScheduleRecurrenceArgs($);
sub parseSchedule($);
sub dowLettersToArr($);
sub dowArrToLetters($);
sub filterByDivisible($$);
sub arrSameElems($$);
sub run(@);
sub readProc(@);
sub readProcLines(@);
sub nowMillis();

my $CONF_FILE = "$ENV{HOME}/.config/timed-cmd.conf";
my $CONF_TYPE_CMD = "command";
my $CONF_TYPE_ALARM = "alarm";

my $EXEC = basename $0;
my $APPLICATION_TIMED_CMD = do{$_=$EXEC; s/\W+/_/g; $_};
my $APPLICATION_ALARM = "nemoalarms";

my $ATT_HOURS = "Hours";
my $ATT_MINUTES = "Minutes";
my $ATT_MONTHS = "Months";
my $ATT_DAYS_OF_WEEK = "Days of week";
my $ATT_DAYS_OF_MONTH = "Days of month";

my $SCHED_ALL = {
  $ATT_HOURS         => [0..23],
  $ATT_MINUTES       => [0..59],
  $ATT_MONTHS        => [qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec)],
  $ATT_DAYS_OF_WEEK  => [qw(Mon Tue Wed Thu Fri Sat Sun)],
  $ATT_DAYS_OF_MONTH => [0..31], #why 0, i couldnt say
};
my @DAYS_OF_WEEK_WEEKDAYS = qw(Mon Tue Wed Thu Fri);
my @DAYS_OF_WEEK_WEEKENDS = qw(Sat Sun);

my @DOW_NAME_ORDER = @{$$SCHED_ALL{$ATT_DAYS_OF_WEEK}};
my %DOW_NAME_TO_LETTER = (
  Mon=>"m", Tue=>"t", Wed=>"w", Thu=>"T", Fri=>"f", Sat=>"s", Sun=>"S",
);
my @DOW_LETTER_ORDER = map {$DOW_NAME_TO_LETTER{$_}} @DOW_NAME_ORDER;
my %DOW_LETTER_TO_NAME = map {$DOW_NAME_TO_LETTER{$_} => $_} @DOW_NAME_ORDER;

my $ACTION_GET_EVENTS = "get-events";
my $ACTION_CLEAR = "clear";
my $ACTION_ADD = "add";
my $ACTION_GET_CONFIGS = "get-configs";
my $ACTION_TOGGLE_CONFIG = "toggle-config";
my $ACTION_APPLY_CONFIG = "apply-config";

my $USAGE = "Usage:
  $EXEC -h | --help
    show this message

  $EXEC [OPTS]
  $EXEC [OPTS] -g | --get
    same as: $EXEC OPTS --get-configs

  $EXEC [OPTS] --get-events
    -fetch all timed event <COOKIE>s for APPLICATION=$APPLICATION_TIMED_CMD
    -extract event attributes and parse TITLE + COMMAND + SCHED_ARGS
      TITLE is the event attribute TITLE
      COMMAND is the event attribute Action0.COMMAND
      SCHED_ARGS is the set of <SCHED> args that will reproduce the sheduling info
    -for each event:
      -if COMMAND is defined, format as:
        <COOKIE> | <TITLE> | <SCHED_ARGS> | <COMMAND>
      -otherwise, format as:
        <COOKIE> | <TITLE> | <SCHED_ARGS>

  $EXEC [OPTS] --get-alarms
    same as: $EXEC OPTS --application=$APPLICATION_ALARM --get

  $EXEC [OPTS] --clear
    -fetch timed event cookies with APPLICATION=$APPLICATION_TIMED_CMD
    -run --cancel-event for each cookie

  $EXEC [OPTS] -a|--add [ONCE | SCHED SCHED ..] --title=TITLE --cmd=COMMAND
    -create timed event to run <COMMAND>
    -defaults to run every minute (which is the smallest granularity)
    -<SCHED> reduces the frequency that <COMMAND> is run

  $EXEC [OPTS] --clear-alarms
    same as: $EXEC OPTS --application=$APPLICATION_ALARM --clear

  $EXEC [OPTS] --add-alarm TITLE TIME_HHMM DAYS_OF_WEEK_LETTERS
    same as: $EXEC OPTS \\
      --add \\
      --application=$APPLICATION_ALARM \\
      --title=TITLE \\
      --no-cmd \\
      --time=TIME_HHMM \\
      --days-of-week-letters=DAYS_OF_WEEK_LETTERS \\
      --event-arg=\"createdDate=`date +%s%3N`\" \\
      --event-arg=\"daysOfWeek=DAYS_OF_WEEK_LETTERS\" \\
      --event-arg=\"timeOfDayWithSeconds=\$((HH*60*60 + MM*60))\" \\
      --event-arg=\"maximalTimeoutSnoozeCounter=2\" \\
      --event-arg=\"type=clock\" \\
      --event-arg=\"alarm\" \\
      --event-arg=\"reminder\" \\
      --event-arg=\"boot\" \\
      --event-arg=\"keepAlive\" \\
      --event-arg=\"alignedSnooze\" \\
    ;

  $EXEC [OPTS] --get-configs
    -fetch the commands + alarms in: $CONF_FILE
    -for commands:
      -parse <TITLE> + <SCHEDULE> + <COMMAND> + <TIMEOUT>
    -for alerts:
      -parse <TITLE> + <TIME_HHMM> + <DAYS_OF_WEEK_LETTERS>
    -fetch all timed event <COOKIE>s and extract <TITLE> attribute for each <COOKIE>
    -for all commands + alerts, extract <ON_OFF_STATUS> + <COOKIE>
      -if TITLE is the same as for any event <COOKIE>:
        ON_OFF_STATUS=on
        COOKIE_FMT=<COOKIE>
      -otherwise:
        ON_OFF_STATUS=off
        COOKIE_FMT=none
    -print header for commands, and print each command formatted:
      <ON_OFF_STATUS> | <TITLE> | <COOKIE_FMT> | <TIMEOUT> | <COMMAND>
    -print header for alerts, and print each alert formatted:
      <ON_OFF_STATUS> | <TITLE> | <COOKIE_FMT> | <TIME_HHMM> | <DAYS_OF_WEEK_LETTERS>

  $EXEC [OPTS] -t CONFIG_TITLE
  $EXEC [OPTS] --toggle CONFIG_TITLE
  $EXEC [OPTS] --toggle=CONFIG_TITLE
    -fetch all timed event <COOKIE>s and extract <TITLE> attribute for each <COOKIE>
    -find matching event where <CONFIG_TITLE> = <TITLE>
      -if found:
        -remove event <COOKIE>
      -otherwise:
        -add this event or alarm as in --apply-cookies

  $EXEC [OPTS] --apply-config
    -clear all $APPLICATION_TIMED_CMD events as in:
      `$EXEC --clear`
    -parse commands and alarms in $CONF_FILE
      alarm = TITLE TIME_HHMM DAYS_OF_WEEK_LETTERS
      cmd = TITLE | SCHED | DAEMON_RUN_TIMEOUT | DAEMON_RUN_ENABLED | SHELL_CMD
    -if TITLE_PATTERN is given, ignore any alarm or cmd that does not match TITLE_PATTERN
    -for each cmd:
      -get FULL_CMD
        -if DAEMON_RUN_TIMEOUT is given and DAEMON_RUN_ENABLED is true:
          -use FULL_CMD = udo daemon-run --name=TITLE --timeout=DAEMON_RUN_TIMEOUT -v SHELL_CMD
        -otherwise:
          -use FULL_CMD = SHELL_CMD
      -add cmd as in:
        `$EXEC --add SCHED --title=TITLE --cmd='FULL_CMD'
    -for each alarm:
      -add alarm as in:
        `$EXEC --add-alarm TITLE_TIME_HH_MM DAYS_OF_WEEK_LETTERS`

  TITLE:
    name of event
    can ONLY contain letters, numbers, underscores, or dashes, for convenience

  COMMAND:
    a shell command
    cannot contain apostrophes/single-quotes ('), for convenience

  ONCE:
    instead of scheduling repeating command,
    add a one-shot to run in TICK_SECONDS from now

    --once=TICK_SECONDS | --tick=TICK_SECOND
      set tick=TICK_SECONDS and dont use schedule

  SCHED:
    restrict which minutes the job will run it
      (default is every minute of any hour of any day)
    effects are cumulative, and the order matters (applied left to right)
      e.g.:
        1h
          => every hour, on the hour
        3h --minutes=15
          => every 3 hours, at a quarter past the hour
        --minutes=15 3h
          => every 3 hours, on the hour
        5m --weekdays
          => every 5 minutes, EXCEPT on Sat or Sun
        --hours=9 --minutes=0 --weekdays='Tue Thu' --months=Nov
          => 09:00am on tuesdays and thursdays in november
        --hours=0 --day-of-month=25 --months=Dec
          => midnight on Newton's birthday

    <MIN>m | <MIN>min | --every-n-min=<MIN> | --every-<MIN>-min
      set minutes = every minute evenly divisible by <MIN>
      MIN = 1 | 2 | 3 | 4 | 5 | 6 | 10 | 12 | 15 | 20 | 30 | 60
      (if this is the only <SCHED>, this means run job every <MIN> minutes)
        e.g.:
          30m                => --minutes='0 30'
          --every-n-min=5    => --minutes='0 5 10 15 20 25 30 35 40 45 50 55'
          --every-15-min     => --minutes='0 15 30 45'

    <HOUR>h | --every-n-hours=<HOUR> | --every-<HOUR>-hours
      set hours = every hour divisible by <HOUR>, AND set minutes = 0
      HOUR = 1 | 2 | 3 | 4 | 6 | 8 | 12 | 24
      (if this is the only <SCHED>, this means run job every <HOUR> hours)
        e.g.:
          4h                 => --hours='0 4 8 12 16 20' --minutes=0
          --every-6-hours    => --hours='0 6 12 18'      --minutes=0
          --every-n-hours=8  => --hours='0 8 16'         --minutes=0

    --time=TIME_HHMM
      clock time formatted as HH:MM
      same as: --hours=HH --minutes=MM

    --every-min
      same as: 1m   (this is the default)

    --hourly
      same as: 60m

    --daily
      same as: 24h

    --weekdays
      same as: --days-of-week=\"Mon Tue Wed Thu Fri\"
    --weekends
      same as: --days-of-week=\"Sat Sun\"

    --days-of-week-leters=DAYS_OF_WEEK_LETTERS
      parse DAYS_OF_WEEK_LETERS into \"<DAY_OF_WEEK> <DAY_OF_WEEK> ...\"
      same as: --days-of-week=\"<DAY_OF_WEEK> <DAY_OF_WEEK> ...\"

    --hours=\"<HOUR> <HOUR> ...\"
      set hours
    --minutes=\"<MIN> <MIN> ...\"
      set minutes
    --months=\"<MONTH> <MONTH> ...\"
      set months
    --days-of-week=\"<DAY_OF_WEEK> <DAY_OF_WEEK> ...\"
      set days-of-week
    --days-of-month=\"<DAY_OF_MONTH> <DAY_OF_MONTH> ...\"
      set days-of-month

  TIME_HHMM
    clock time, 24-hour, formatted 'HH:MM'

  DAYS_OF_WEEK_LETTERS
    case-sensitive string of up to 7 characters, one for each day of the week to include
      e.g.:   mtwTfsS = every day
              mtwTf   = weekdays
    m = monday
    t = tuesday
    w = wednesday
    T = thursday
    f = friday
    s = saturday
    S = sunday

  OPTS
    --application=APPLICATION | --app=APPLICATION
      use APPLICATION instead of $APPLICATION_TIMED_CMD

    --no-cmd
      same as: --cmd=''
      do not include a 'whenDue runComand' action

    --event-arg=EXTRA_EVENT_ARG
      (can be given multiple times)
      when adding events, append EXTRA_EVENT_ARG to semicolon-separated list
        in 'timedclient-t5 -e'
";

sub main(@){
  my $action = $ACTION_GET_CONFIGS;
  my $opts = {
    application    => $APPLICATION_TIMED_CMD,
    title          => undef,
    shellCmd       => undef,
    onceTick       => undef,
    schedArgs      => {},
    extraEventArgs => [],
  };
  while(@_ > 0){
    my $arg = shift @_;
    if($arg =~ /^(-h|--help)$/){
      print "$USAGE\n";
      exit 0;
    }elsif($arg =~ /^(?:--app|--application)=(.+)$/){
      $$opts{application} = $1;
    }elsif($arg =~ /^--event-arg=(.+)$/){
      push @{$$opts{extraEventArgs}}, $1;
    }elsif($arg =~ /^(-g|--get)$/){
      $action = $ACTION_GET_CONFIGS;
    }elsif($arg =~ /^(--get-events)$/){
      $action = $ACTION_GET_EVENTS;
    }elsif($arg =~ /^--get-alarms$/){
      $action = $ACTION_GET_EVENTS;
      $$opts{application} = $APPLICATION_ALARM;
    }elsif($arg =~ /^(--clear)$/){
      $action = $ACTION_CLEAR;
    }elsif($arg =~ /^(--clear-alarms)$/){
      $action = $ACTION_CLEAR;
      $$opts{application} = $APPLICATION_ALARM;
    }elsif($arg =~ /^(-a|--add)$/){
      $action = $ACTION_ADD;
    }elsif($arg =~ /^--get-configs$/){
      $action = $ACTION_GET_CONFIGS;
    }elsif($arg =~ /^(-t|--toggle)$/ and @_ > 0){
      $action = $ACTION_TOGGLE_CONFIG;
      $$opts{title} = shift @_;
    }elsif($arg =~ /^--toggle=(.+)$/){
      $action = $ACTION_TOGGLE_CONFIG;
      $$opts{title} = $1;
    }elsif($arg =~ /^(--apply-config)$/){
      $action = $ACTION_APPLY_CONFIG;
    }elsif($arg =~ /^(--add-alarm)$/){
      if(@_ != 3){
        die "$USAGE\nERROR: --add-alarm requires 3 arguments\n";
      }
      my ($titleArg, $hhmmArg, $daysOfTheWeekLettersArg) = @_;
      @_ = ();

      my ($h, $m);
      if($hhmmArg =~ /^(\d|\d\d):(\d\d)$/){
        ($h, $m) = ($1, $2);
      }else{
        die "ERROR: malformed HH:MM $hhmmArg\n";
      }
      die "ERROR: malformed HH:MM $hhmmArg\n" if $h >= 24;
      die "ERROR: malformed HH:MM $hhmmArg\n" if $m >= 60;

      $action = $ACTION_ADD;
      $$opts{application} = $APPLICATION_ALARM;
      $$opts{title} = $titleArg;
      $$opts{shellCmd} = '';
      $$opts{schedArgs}{$ATT_HOURS} = [0+$h];
      $$opts{schedArgs}{$ATT_MINUTES} = [0+$m];
      $$opts{schedArgs}{$ATT_DAYS_OF_WEEK} = [dowLettersStrToNamesArr($daysOfTheWeekLettersArg)];
      push @{$$opts{extraEventArgs}}, "createdDate=" . nowMillis();
      push @{$$opts{extraEventArgs}}, "daysOfWeek=$daysOfTheWeekLettersArg";
      push @{$$opts{extraEventArgs}}, "timeOfDayWithSeconds=" . ($h*60*60 + $m*60);
      push @{$$opts{extraEventArgs}}, "maximalTimeoutSnoozeCounter=2"; #not implemented in timedclient-qt5 as of 3.6.13-1.8.1
      push @{$$opts{extraEventArgs}}, "type=clock";
      push @{$$opts{extraEventArgs}}, "alarm";
      push @{$$opts{extraEventArgs}}, "reminder";
      push @{$$opts{extraEventArgs}}, "boot";
      push @{$$opts{extraEventArgs}}, "keepAlive";
      push @{$$opts{extraEventArgs}}, "alignedSnooze";
    }elsif($arg =~ /^--title=(.+)$/){
      $$opts{title} = $1;
    }elsif($arg =~ /^--cmd=(.*)$/){
      $$opts{shellCmd} = $1;
    }elsif($arg =~ /^--no-cmd$/){
      $$opts{shellCmd} = ""; #empty command omits '-a'
    }elsif($arg =~ /^(?:--once|--tick)=(\d+)$/){
      $$opts{onceTick} = $1;
    }elsif($arg =~ /^(--days-of-week|--days-of-week-letters|--months|--days-of-month|--hours|--minutes|--time)=(.+)$/){
      my ($field, $valStr) = ($1, $2);
      my $vals = [split /[ ,]+/, $valStr];
      if($field =~ /^(--days-of-week)$/){
        for my $dayOfWeek(@$vals){
          die "ERROR: malformed day-of-week: $dayOfWeek\n"
            if $dayOfWeek !~ /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun)$/;
        }
        $$opts{schedArgs}{$ATT_DAYS_OF_WEEK} = $vals;
      }elsif($field =~ /^(--days-of-week-letters)$/){
        $$opts{schedArgs}{$ATT_DAYS_OF_WEEK} = [dowLettersStrToNamesArr($valStr)];
      }elsif($field =~ /^(--months)$/){
        for my $month(@$vals){
          die "ERROR: malformed month: $month\n"
            if $month !~ /^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)$/;
        }
        $$opts{schedArgs}{$ATT_MONTHS} = $vals;
      }elsif($field =~ /^(--days-of-month)$/){
        for my $dayOfMonth(@$vals){
          die "ERROR: malformed day-of-month: $dayOfMonth\n"
            if $dayOfMonth !~ /^\d+$/ or $dayOfMonth > 31;
        }
        $$opts{schedArgs}{$ATT_DAYS_OF_MONTH} = [map {0+$_} @$vals];
      }elsif($field =~ /^(--hours)$/){
        for my $hour(@$vals){
          die "ERROR: malformed hour: $hour\n" if $hour !~ /^\d+$/ or $hour >= 24;
        }
        $$opts{schedArgs}{$ATT_HOURS} = [map {0+$_} @$vals];
      }elsif($field =~ /^(--minutes)$/){
        for my $min(@$vals){
          die "ERROR: malformed min: $min\n" if $min !~ /^\d+$/ or $min >=60;
        }
        $$opts{schedArgs}{$ATT_MINUTES} = [map {0+$_} @$vals];
      }elsif($field =~ /^(--time)$/){
        for my $time(@$vals){
          if($time =~ /^(\d|\d\d):(\d\d)$/){
            my ($h, $m) = ($1, $2);
            push @{$$opts{schedArgs}{$ATT_HOURS}}, 0+$h;
            push @{$$opts{schedArgs}{$ATT_MINUTES}}, 0+$m;
          }else{
            die "ERROR: malformed time $time\n";
          }
        }
      }else{
        die "ERROR: malformed sched arg: $arg\n";
      }
    }elsif($arg =~ /^(\d+m|\d+min|--every-n-min=\d+|--every-\d+-min)$/){
      my $factor = 0+$1 if $arg =~ /(\d+)/;
      if(not defined $factor or $factor !~ /^(1|2|3|4|5|6|10|12|15|20|30|60)$/){
        die "ERROR: --every-n-minute can only accept divisors of 60\n";
      }
      $$opts{schedArgs}{$ATT_MINUTES} = filterByDivisible $factor, $$SCHED_ALL{$ATT_MINUTES};
    }elsif($arg =~ /^(\d+h|--every-n-hours=\d+|--every-\d+-hours)$/){
      my $factor = 0+$1 if $arg =~ /(\d+)/;
      if(not defined $factor or $factor !~ /^(1|2|3|4|6|8|12)$/){
        die "ERROR: --every-n-hours can only accept divisors of 24\n";
      }
      $$opts{schedArgs}{$ATT_HOURS} = filterByDivisible $factor, $$SCHED_ALL{$ATT_HOURS};
      $$opts{schedArgs}{$ATT_MINUTES} = [0];
    }elsif($arg =~ /^(--every-min)$/){
      $$opts{schedArgs}{$ATT_MINUTES} = filterByDivisible 1, $$SCHED_ALL{$ATT_MINUTES};
    }elsif($arg =~ /^(--hourly)$/){
      $$opts{schedArgs}{$ATT_MINUTES} = filterByDivisible 60, $$SCHED_ALL{$ATT_MINUTES};
    }elsif($arg =~ /^(--daily)$/){
      $$opts{schedArgs}{$ATT_HOURS} = filterByDivisible 24, $$SCHED_ALL{$ATT_HOURS};
      $$opts{schedArgs}{$ATT_MINUTES} = [0];
    }elsif($arg =~ /^(--weekdays)$/){
      $$opts{schedArgs}{$ATT_DAYS_OF_WEEK} = [@DAYS_OF_WEEK_WEEKDAYS];
    }elsif($arg =~ /^(--weekends)$/){
      $$opts{schedArgs}{$ATT_DAYS_OF_WEEK} = [@DAYS_OF_WEEK_WEEKENDS];
    }else{
      die "$USAGE\nERROR: unknown arg '$arg'\n";
    }
  }

  if($action eq $ACTION_GET_EVENTS){
    die "$USAGE\nERROR: cannot specify SCHEDULE for action=$action\n" if %{$$opts{schedArgs}} > 0;
    die "$USAGE\nERROR: cannot specify TITLE for action=$action\n" if defined $$opts{title};
    die "$USAGE\nERROR: cannot specify COMMAND for action=$action\n" if defined $$opts{shellCmd};

    my @cookies = getTimedCmdEventCookies($$opts{application});
    my %eventsByCookie = map {$_ => getTimedCmdEventInfo $_} @cookies;
    my $maxTitleLen = max(map {length $$_{TITLE}} values %eventsByCookie);
    for my $cookie(@cookies){
      my $event = $eventsByCookie{$cookie};
      my $eventFmt;
      if(defined $$event{COMMAND}){
        $eventFmt = sprintf "%4d | %-${maxTitleLen}s | %3s | %s",
          $cookie,
          $$event{TITLE},
          $$event{timingFmt},
          $$event{COMMAND},
        ;
      }else{
        $eventFmt = sprintf "%4d | %-${maxTitleLen}s | %s",
          $cookie,
          $$event{TITLE},
          $$event{timingFmt},
        ;
      }
      print "$eventFmt\n";
    }
  }elsif($action eq $ACTION_CLEAR){
    die "$USAGE\nERROR: cannot specify SCHEDULE for action=$action\n" if %{$$opts{schedArgs}} > 0;
    die "$USAGE\nERROR: cannot specify TITLE for action=$action\n" if defined $$opts{title};
    die "$USAGE\nERROR: cannot specify COMMAND for action=$action\n" if defined $$opts{shellCmd};

    my @cookies = getTimedCmdEventCookies($$opts{application});
    for my $cookie(@cookies){
      run "timedclient-qt5", "--cancel-event", $cookie;
    }
  }elsif($action eq $ACTION_ADD){
    die "$USAGE\nERROR: must specify TITLE for action=$action\n" if not defined $$opts{title};
    die "$USAGE\nERROR: must specify COMMAND for action=$action\n" if not defined $$opts{shellCmd};

    if(defined $$opts{onceTick} and %{$$opts{schedArgs}} > 0){
      die "ERROR: cannot specify both SCHED and ONCE\n";
    }

    if($$opts{title} !~ /^[a-zA-Z0-9_\-]+$/){
      die "ERROR: TITLE can only contain letters/numbers/underscores/dashes\n";
    }
    if($$opts{shellCmd} =~ /'/){
      die "ERROR: COMMAND cannot contain apostrophes (for $EXEC convenience)\n";
    }

    my @actionArgs = length $$opts{shellCmd} > 0 ? ("whenDue", "runCommand=$$opts{shellCmd}") : ();
    my @eventArgs = (
      "APPLICATION=$$opts{application}",
      "TITLE=$$opts{title}",
      @{$$opts{extraEventArgs}},
    );

    my @recurrenceArgs;
    if(defined $$opts{onceTick}){
      print "adding command with ticker=$$opts{onceTick}\n";
      push @eventArgs, "ticker=$$opts{onceTick}";
      @recurrenceArgs = ();
    }else{
      my $sched = {%$SCHED_ALL, %{$$opts{schedArgs}}};

      print "adding command with schedule: " . parseSchedule($sched) . "\n";
      @recurrenceArgs = getScheduleRecurrenceArgs($sched);
    }

    my @cmd = ("timedclient-qt5");
    @cmd = (@cmd, "-a", join(";", @actionArgs)) if @actionArgs > 0;
    @cmd = (@cmd, "-r", join(";", @recurrenceArgs)) if @recurrenceArgs > 0;
    @cmd = (@cmd, "-e", join(";", @eventArgs)) if @eventArgs > 0;

    run @cmd;
  }elsif($action eq $ACTION_GET_CONFIGS){
    die "$USAGE\nERROR: cannot specify SCHEDULE for action=$action\n" if %{$$opts{schedArgs}} > 0;
    die "$USAGE\nERROR: cannot specify TITLE for action=$action\n" if defined $$opts{title};
    die "$USAGE\nERROR: cannot specify COMMAND for action=$action\n" if defined $$opts{shellCmd};

    my $conf = readConf($CONF_FILE);

    my @allCookies = getAllEventCookies();
    my %eventsByCookie = map {$_ => getTimedCmdEventInfo $_} @allCookies;
    my %cookiesByTitle = map {$eventsByCookie{$_}{TITLE} => $_} sort @allCookies;

    my $maxTitleLen = max(
      map {length $$_{title}} (@{$$conf{commands}}, @{$$conf{alarms}})
    );

    printf "%s|---COMMAND%s|%s|%s|%s|%s\n",
      "-"x(3+1), "-"x($maxTitleLen-10+2), "-"x(4+2), "-"x(5+2), "-"x(5+2), "-"x5;
    for my $cmd(@{$$conf{commands}}){
      my $cookie = $cookiesByTitle{$$cmd{title}};
      my $status;
      if(defined $cookie){
        $status = "on";
      }else{
        $status = "off";
        $cookie = "none";
      }
      printf "%-3s | %-${maxTitleLen}s | %4s | %5s | %5s | %s\n",
        $status,
        $$cmd{title},
        $cookie,
        $$cmd{sched},
        $$cmd{timeout},
        $$cmd{cmd},
      ;
    }

    printf "%s|---ALARM%s|%s|%s|%s|%s\n",
      "-"x(3+1), "-"x($maxTitleLen-8+2), "-"x(4+2), "-"x(5+2), "-"x(5+2), "-"x5;
    for my $cmd(@{$$conf{alarms}}){
      my $cookie = $cookiesByTitle{$$cmd{title}};
      my $status;
      if(defined $cookie){
        $status = "on";
      }else{
        $status = "off";
        $cookie = "none";
      }
      printf "%-3s | %-${maxTitleLen}s | %4s | %5s | %s\n",
        $status,
        $$cmd{title},
        $cookie,
        $$cmd{timeHHMM},
        $$cmd{daysOfWeekLetters},
      ;
    }
 }elsif($action eq $ACTION_TOGGLE_CONFIG){
    die "$USAGE\nERROR: cannot specify SCHEDULE for action=$action\n" if %{$$opts{schedArgs}} > 0;
    die "$USAGE\nERROR: cannot specify COMMAND for action=$action\n" if defined $$opts{shellCmd};
    die "$USAGE\nERROR: must specify TITLE for action=$action\n" if not defined $$opts{title};

    my $conf = readConf($CONF_FILE);
    my $targetConfEntry = undef;
    for my $confEntry(@{$$conf{commands}}, @{$$conf{alarms}}){
      if($$confEntry{title} eq $$opts{title}){
        $targetConfEntry = $confEntry;
        last;
      }
    }
    if(not defined $targetConfEntry){
      die "ERROR: unknown conf entry title '$$opts{title}'\n";
    }

    my @allCookies = getAllEventCookies();
    my %eventsByCookie = map {$_ => getTimedCmdEventInfo $_} @allCookies;
    my %cookiesByTitle = map {$eventsByCookie{$_}{TITLE} => $_} sort @allCookies;

    if(defined $cookiesByTitle{$$opts{title}}){
      run "timedclient-qt5", "--cancel-event", $cookiesByTitle{$$opts{title}};
    }else{
      addConfEntry($targetConfEntry);
    }
  }elsif($action eq $ACTION_APPLY_CONFIG){
    die "$USAGE\nERROR: cannot specify SCHEDULE for action=$action\n" if %{$$opts{schedArgs}} > 0;
    die "$USAGE\nERROR: cannot specify TITLE for action=$action\n" if defined $$opts{title};
    die "$USAGE\nERROR: cannot specify COMMAND for action=$action\n" if defined $$opts{shellCmd};
    my $conf = readConf($CONF_FILE);

    print "\nclearing commands\n";
    run $EXEC, "--clear";
    print "\n\n\n";

    print "\nadding commands\n";
    for my $cmdEntry(@{$$conf{commands}}){
      print "\n";
      addConfEntry($cmdEntry);
    }

    print "\n";

    print "\nclearing alarms\n";
    system $EXEC, "--clear-alarms";

    print "\nadding alarms\n";
    for my $alarmEntry(@{$$conf{alarms}}){
      print "\n";
      addConfEntry($alarmEntry);
    }

    print "\n";

    print "\n\ncommands:\n";
    run $EXEC, "--get-events";

    print "\n\nalarms:\n";
    run $EXEC, "--get-alarms";
  }else{
    die "ERROR: unknown action $action\n";
  }
}

sub readConf($){
  my ($file) = @_;
  my $conf = {
    commands => [],
    alarms   => [],
  };
  if(not -e $file){
    return $conf;
  }

  open my $fh, "<", $file or die "ERROR: could not read $file\n$!\n";
  my @lines = <$fh>;
  close $fh;

  for my $line(@lines){
    next if $line =~ /^\s*(#.*)?$/;
    if($line =~ /^
      \s* alarm \s* =
      \s* (\w+) \s* \|
      \s* (\d+:\d+) \s* \|
      \s* ([mtwTfsS]+) \s*
      $
    /xi){
      push @{$$conf{alarms}}, {
        type              => $CONF_TYPE_ALARM,
        title             => $1,
        timeHHMM          => $2,
        daysOfWeekLetters => $3,
      };
    }elsif($line =~ /
      ^
      \s* cmd \s* =
      \s* ([a-zA-Z0-9_\-]+) \s* \|
      \s* (\w+) \s* \|
      \s* (\w+) \s* \|
      \s* (true|false) \s* \|
      \s* (\S.*\S)
      \s*
      $
    /xi){
      push @{$$conf{commands}}, {
        type      => $CONF_TYPE_CMD,
        title     => $1,
        sched     => $2,
        timeout   => $3,
        useDaemon => $4,
        cmd       => $5,
      };
    }else{
      die "ERROR: malformed entry in $CONF_FILE\n$line";
    }
  }

  return $conf;
}

sub addConfEntry($){
  my ($confEntry) = @_;
  if($$confEntry{type} eq $CONF_TYPE_CMD){
    my $title = $$confEntry{title};
    my $sched = $$confEntry{sched};
    my $timeout = $$confEntry{timeout};
    my $useDaemon = $$confEntry{useDaemon};
    my $shellCmd = $$confEntry{cmd};

    my @fullCmd;
    if($useDaemon =~ /true/){
      @fullCmd = (
        "udo", "daemon-run",
        "--name=$title", "--timeout=$timeout",
        "--verbose",
        $shellCmd,
      );
    }else{
      @fullCmd = ($shellCmd);
    }

    run $EXEC, "--add", "$sched", "--title=$title", "--cmd=@fullCmd";
  }elsif($$confEntry{type} eq $CONF_TYPE_ALARM){
    my $title = $$confEntry{title};
    my $timeHHMM = $$confEntry{timeHHMM};
    my $daysOfWeekLetters = $$confEntry{daysOfWeekLetters};
    run $EXEC, "--add-alarm", $title, $timeHHMM, $daysOfWeekLetters;
  }else{
    die "ERROR: unknown conf type $$confEntry{type}\n";
  }
}

sub getAllEventCookies(){
  my $out = readProc "timedclient-qt5", "--list";
  return $out =~ /\d+/g;
}

sub getTimedCmdEventCookies($){
  my ($application) = @_;
  my $out = readProc "timedclient-qt5", "--search", "APPLICATION=$application";
  return $out =~ /\d+/g;
}

sub getTimedCmdEventInfo($){
  my ($eventCookie) = @_;
  my @lines = readProcLines "timedclient-qt5", "--get-event=$eventCookie";
  my $okAtts = join "|", qw(APPLICATION TITLE COMMAND USER);
  my $okSchedAtts = join "|", (
    $ATT_HOURS, $ATT_MINUTES, $ATT_MONTHS, $ATT_DAYS_OF_WEEK, $ATT_DAYS_OF_MONTH,
  );

  my $event = {
    schedule => undef,
    scheduleFmt => undef,
    tick => undef,
    tickFmt => undef,
    timingFmt => undef,
  };
  for my $line(@lines){
    if($line =~ /^\s*($okAtts)\s*=\s*'(.+)'$/){
      $$event{$1} = $2;
    }elsif($line =~ /^\s*($okSchedAtts)\s*:\s*(.+)$/){
      my ($att, $val) = ($1, $2);
      my @vals = split /\s+/, $val;
      $$event{schedule} = {} if not defined $$event{schedule};
      $$event{schedule}{$att} = [@vals];
    }elsif($line =~ /^\s*Tick: (\d+) \((.*)\)$/){
      $$event{tick} = $1;
      $$event{tickFmt} = $2;
    }
  }
  if(defined $$event{schedule}){
    $$event{scheduleFmt} = parseSchedule($$event{schedule});
  }

  if(defined $$event{schedule}){
    $$event{timingFmt} = $$event{scheduleFmt};
  }elsif(defined $$event{tick}){
    $$event{timingFmt} = "$$event{tick} ($$event{tickFmt})";
  }

  return $event;
}

sub getScheduleRecurrenceArgs($){
  my ($sched) = @_;
  my @args;

  for my $hour(@{$$sched{$ATT_HOURS}}){
    push @args, "hour=$hour";
  }

  for my $minute(@{$$sched{$ATT_MINUTES}}){
    push @args, "minute=$minute";
  }

  if(arrSameElems($$sched{$ATT_DAYS_OF_MONTH}, $$SCHED_ALL{$ATT_DAYS_OF_MONTH})){
    push @args, "everyDayOfMonth";
  }else{
    for my $dayOfMonth(@{$$sched{$ATT_DAYS_OF_MONTH}}){
      push @args, "dayOfMonth=$dayOfMonth";
    }
  }

  if(arrSameElems($$sched{$ATT_DAYS_OF_WEEK}, $$SCHED_ALL{$ATT_DAYS_OF_WEEK})){
    push @args, "everyDayOfWeek";
  }else{
    for my $dayOfWeek(@{$$sched{$ATT_DAYS_OF_WEEK}}){
      push @args, "dayOfWeek=$dayOfWeek";
    }
  }

  if(arrSameElems($$sched{$ATT_MONTHS}, $$SCHED_ALL{$ATT_MONTHS})){
    push @args, "everyMonth";
  }else{
    for my $month(@{$$sched{$ATT_MONTHS}}){
      my %monthIds = (
        Jan => 2,
        Feb => 3,
        Mar => 4,
        Apr => 5,
        May => 6,
        Jun => 7,
        Jul => 8,
        Aug => 9,
        Sep => 10,
        Oct => 11,
        Nov => 12,
        Dec => undef,
      );
      my $monthId = $monthIds{$month};
      if(not defined $monthId){
        die "ERROR: some ridiculous timed off-by-one bug thinks Jan=2 and Dec=13\n"
          . "this completely prevents adding December, except with everyMonth...\n"
          ;
      }
      push @args, "month=$monthId";
    }
  }
  return @args;
}

sub parseSchedule($){
  my ($schedule) = @_;
  my $hr = $$schedule{$ATT_HOURS};
  my $min = $$schedule{$ATT_MINUTES};
  my $isAllHr = arrSameElems($hr, $$SCHED_ALL{$ATT_HOURS});
  my $isAllMin = arrSameElems($min, $$SCHED_ALL{$ATT_MINUTES});

  my @schedArgs;
  if(@schedArgs == 0 and @$min == 1){
    for my $hrFactor(qw(1 2 3 4 6 8 12 24)){
      my $factorHrs = filterByDivisible $hrFactor, $$SCHED_ALL{$ATT_HOURS};
      if(arrSameElems($hr, $factorHrs)){
        push @schedArgs, "${hrFactor}h";
        push @schedArgs, "--minutes=$$min[0]" if $$min[0] != 0;
        last;
      }
    }
  }

  if(@schedArgs == 0 and $isAllHr){
    for my $minFactor(qw(1 2 3 4 5 6 10 12 15 20 30)){
      my $factorMins = filterByDivisible $minFactor, $$SCHED_ALL{$ATT_MINUTES};
      if(arrSameElems($min, $factorMins)){
        push @schedArgs, "${minFactor}m";
        last;
      }
    }
  }

  if(@schedArgs == 0){
    if(@$hr == 1 and @$min == 1){
      push @schedArgs, sprintf("--time=%02d:%02d", $$hr[0], $$min[0]);
    }else{
      push @schedArgs, "--hours='@$hr'" if not $isAllHr;
      push @schedArgs, "--minutes='@$min'" if not $isAllMin;
    }
  }

  if(not arrSameElems($$schedule{$ATT_DAYS_OF_WEEK}, $$SCHED_ALL{$ATT_DAYS_OF_WEEK})){
    if(arrSameElems($$schedule{$ATT_DAYS_OF_WEEK}, [@DAYS_OF_WEEK_WEEKDAYS])){
      push @schedArgs, "--weekdays";
    }elsif(arrSameElems($$schedule{$ATT_DAYS_OF_WEEK}, [@DAYS_OF_WEEK_WEEKENDS])){
      push @schedArgs, "--weekends";
    }else{
      push @schedArgs, "--days-of-week='@{$$schedule{$ATT_DAYS_OF_WEEK}}'";
    }
  }
  if(not arrSameElems($$schedule{$ATT_MONTHS}, $$SCHED_ALL{$ATT_MONTHS})){
    push @schedArgs, "--months='{$$schedule{$ATT_MONTHS}}'";
  }
  if(not arrSameElems($$schedule{$ATT_DAYS_OF_MONTH}, $$SCHED_ALL{$ATT_DAYS_OF_MONTH})){
    push @schedArgs, "--days-of-month='{$$schedule{$ATT_DAYS_OF_MONTH}}'";
  }

  return "@schedArgs";
}

sub dowLettersStrToNamesArr($){
  my ($dowLettersStr) = @_;
  my %okLetters = map {$_ => 1} split //, $dowLettersStr;
  for my $letter(sort keys %okLetters){
    die "ERROR: unknown DOW letter $letter\n" if not defined $DOW_LETTER_TO_NAME{$letter};
  }
  return map {$DOW_LETTER_TO_NAME{$_}} grep {defined $okLetters{$_}} @DOW_LETTER_ORDER
}
sub dowNamesArrToLettersStr(@){
  my (@dowNamesArr) = @_;
  my %okNames = map {$_ => 1} @dowNamesArr;
  for my $name(sort keys %okNames){
    die "ERROR: unknown DOW name $name\n" if not defined $DOW_NAME_TO_LETTER{$name};
  }
  return map {$DOW_NAME_TO_LETTER{$_}} grep {defined $okNames{$_}} @DOW_NAME_ORDER
}

sub filterByDivisible($$){
  my ($factor, $arr) = @_;
  return [grep {$_ % $factor == 0} @$arr];
}

sub arrSameElems($$){
  my ($arrRef1, $arrRef2) = @_;
  return 0 if @$arrRef1 != @$arrRef2;

  my @arr1 = sort @$arrRef1;
  my @arr2 = sort @$arrRef2;
  for(my $i=0; $i<@arr1; $i++){
    if($arr1[$i] ne $arr2[$i]){
      return 0;
    }
  }
  return 1;
}

sub run(@){
  print "@_\n";
  system @_;
  die "ERROR: \"@_\" failed\n" if $? != 0;
}
sub readProc(@){
  return join '', readProcLines @_;
}
sub readProcLines(@){
  open CMD, "-|", @_ or die "ERROR: could not run \"@_\"\n$!\n";
  my @lines = <CMD>;
  close CMD;
  die "ERROR: \"@_\" failed\n" if $? != 0;
  return @lines;
}

sub nowMillis(){
  return int(time * 1000.0 + 0.5);
}

&main(@ARGV);
