#!/usr/bin/perl
use strict;
use warnings;
use File::Basename qw(basename);
use List::Util qw(max);
use Time::HiRes qw(time);

sub readConf($);
sub addEventFromConfEntry($);
sub getEventCookiesAll();
sub getEventCookiesForApplication($);
sub getTimedCmdEventInfo($);
sub getScheduleRecurrenceArgs($);
sub applySchedArg($$);
sub parseSchedule($);
sub dowLettersToArr($);
sub dowArrToLetters($);
sub filterByDivisible($$);
sub arrSameElems($$);
sub run(@);
sub readProc(@);
sub readProcLines(@);
sub nowMillis();

my $CONF_FILE = "$ENV{HOME}/.config/timed-cmd.conf";
my $CONF_TYPE_CMD = "command";
my $CONF_TYPE_ALARM = "alarm";

my $EXEC = basename $0;
my $APPLICATION_TIMED_CMD = do{$_=$EXEC; s/\W+/_/g; $_};
my $APPLICATION_ALARM = "nemoalarms";

my $ATT_HOURS = "Hours";
my $ATT_MINUTES = "Minutes";
my $ATT_MONTHS = "Months";
my $ATT_DAYS_OF_WEEK = "Days of week";
my $ATT_DAYS_OF_MONTH = "Days of month";

my $SCHED_ALL = {
  $ATT_HOURS         => [0..23],
  $ATT_MINUTES       => [0..59],
  $ATT_MONTHS        => [qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec)],
  $ATT_DAYS_OF_WEEK  => [qw(Mon Tue Wed Thu Fri Sat Sun)],
  $ATT_DAYS_OF_MONTH => [0..31], #why 0, i couldnt say
};

my @DOW_NAME_ORDER = @{$$SCHED_ALL{$ATT_DAYS_OF_WEEK}};
my %DOW_NAME_TO_LETTER = (
  Mon=>"m", Tue=>"t", Wed=>"w", Thu=>"T", Fri=>"f", Sat=>"s", Sun=>"S",
);
my @DOW_LETTER_ORDER = map {$DOW_NAME_TO_LETTER{$_}} @DOW_NAME_ORDER;
my %DOW_LETTER_TO_NAME = map {$DOW_NAME_TO_LETTER{$_} => $_} @DOW_NAME_ORDER;

my $SCHED_ARG_REGEX = join("|",
  '(?:days-of-week|dow|months|days-of-month|hours|minutes)=(?:.+)',
  '(?:(?:\d|\d\d):(?:\d\d))',
  '(?:@\d+m)',
  '(?:@\d+h)',
);

my $ACTION_GET_EVENTS = "get-events";
my $ACTION_CLEAR = "clear";
my $ACTION_ADD = "add";
my $ACTION_GET_CONFIGS = "get-configs";
my $ACTION_TOGGLE_CONFIG = "toggle-config";
my $ACTION_APPLY_CONFIG = "apply-config";

my $USAGE = "Usage:
  $EXEC -h | --help
    show this message

  $EXEC [OPTS]
  $EXEC [OPTS] -g | --get
    same as: $EXEC OPTS --get-configs

  $EXEC [OPTS] --get-events
    -fetch all timed event <COOKIE>s
      -if --application is given, limit to APPLICATION
    -extract event attributes and parse TITLE + COMMAND + SCHED_ARGS
      TITLE is the event attribute TITLE
      COMMAND is the event attribute Action0.COMMAND
      SCHED_ARGS is the set of <SCHED> args that will reproduce the sheduling info
    -for each event:
      -if COMMAND is defined, format as:
        <COOKIE> | <TITLE> | <SCHED_ARGS> | <COMMAND>
      -otherwise, format as:
        <COOKIE> | <TITLE> | <SCHED_ARGS>

  $EXEC [OPTS] --clear
    -fetch all timed event <COOKIE>s
      -if --application is given, limit to APPLICATION
    -for each <COOKIE>, run: timedclient-qt5 --cancel-event <COOKIE>

  $EXEC [OPTS] -a|--add [ONCE | SCHED SCHED ..] --title=TITLE --cmd=COMMAND
  $EXEC [OPTS] -a|--add [ONCE | SCHED SCHED ..] --title=TITLE --alarm
    -select application
      -if --application is given, use APPLICATION
      -if --cmd is given, use $APPLICATION_TIMED_CMD
      -if --alarm is given, use $APPLICATION_ALARM
    -create timed event to run <COMMAND>
    -defaults to run every minute (which is the smallest granularity)
    -<SCHED> reduces the frequency that <COMMAND> is run

  $EXEC [OPTS] --get-configs
    -fetch the commands + alarms in: $CONF_FILE
    -for commands:
      -parse <TITLE> + <SCHEDULE> + <COMMAND> + <TIMEOUT>
    -for alarms:
      -parse <TITLE> + <SCHEDULE>
    -fetch all timed event <COOKIE>s and extract <TITLE> attribute for each <COOKIE>
    -for all commands + alarms, extract <ON_OFF_STATUS> + <COOKIE>
      -if TITLE is the same as for any event <COOKIE>:
        ON_OFF_STATUS=on
        COOKIE_FMT=<COOKIE>
      -otherwise:
        ON_OFF_STATUS=off
        COOKIE_FMT=none
    -print header for commands, and print each command formatted:
      <ON_OFF_STATUS> | <TITLE> | <COOKIE_FMT> | <TIMEOUT> | <COMMAND>
    -print header for alarms, and print each alarm formatted:
      <ON_OFF_STATUS> | <TITLE> | <COOKIE_FMT> | <TIME_HHMM> | <DAYS_OF_WEEK_LETTERS>

  $EXEC [OPTS] -t CONFIG_TITLE
  $EXEC [OPTS] --toggle CONFIG_TITLE
  $EXEC [OPTS] --toggle=CONFIG_TITLE
    -fetch all timed event <COOKIE>s and extract <TITLE> attribute for each <COOKIE>
    -find matching event where <CONFIG_TITLE> = <TITLE>
      -if found:
        -remove event <COOKIE>
      -otherwise:
        -add this event or alarm as in --apply-cookies

  $EXEC [OPTS] --apply-config
    -clear ALL EVENTS as in:
      `$EXEC --clear`
    -parse commands and alarms in $CONF_FILE
      alarm = TITLE TIME_HHMM DAYS_OF_WEEK_LETTERS
      cmd = TITLE | SCHED | DAEMON_RUN_TIMEOUT | DAEMON_RUN_ENABLED | SHELL_CMD
    -for each cmd:
      -get FULL_CMD
        -if DAEMON_RUN_TIMEOUT is given and DAEMON_RUN_ENABLED is true:
          -use FULL_CMD = udo daemon-run --name=TITLE --timeout=DAEMON_RUN_TIMEOUT -v SHELL_CMD
        -otherwise:
          -use FULL_CMD = SHELL_CMD
      -add cmd as in:
        `$EXEC --add SCHED --title=TITLE --cmd='FULL_CMD'
    -for each alarm:
      -add alarm as in:
        `$EXEC --add --alarm --title=TITLE TIME_HHMM dow=DAYS_OF_WEEK_LETTERS`

  TITLE:
    name of event
    can ONLY contain letters, numbers, underscores, or dashes, for convenience

  COMMAND:
    a shell command
    cannot contain apostrophes/single-quotes ('), for convenience

  ONCE:
    instead of scheduling repeating command,
    add a one-shot to run in TICK_SECONDS from now

    --once=TICK_SECONDS | --tick=TICK_SECOND
      set tick=TICK_SECONDS and dont use schedule

  SCHED:
    restrict which minutes the job will run it
      (default is every minute of any hour of any day)
    effects are cumulative, and the order matters (applied left to right)
      e.g.:
        \@1h
          => every hour, on the hour
        \@3h minutes=15
          => every 3 hours, at a quarter past the hour
        minutes=15 \@3h
          => every 3 hours, on the hour
        \@5m dow=mtwTf
          => every 5 minutes, EXCEPT on Sat or Sun
        hours=9 minutes=0 dow=tT months=Nov
          => 09:00am on tuesdays and thursdays in november
        hours=0 day-of-month=25 months=Dec
          => midnight on Newton's birthday

    \@<MIN>m
      set minutes = every minute evenly divisible by <MIN>
      MIN = 1 | 2 | 3 | 4 | 5 | 6 | 10 | 12 | 15 | 20 | 30 | 60
      (if this is the only <SCHED>, this means run job every <MIN> minutes)
        e.g.:
          \@30m  =>  minutes=0,30
          \@5m   =>  minutes=0,5,10,15,20,25,30,35,40,45,50,55
          \@15m  =>  minutes=0,15,30,45

    \@<HOUR>h
      set hours = every hour divisible by <HOUR>, AND set minutes = 0
      HOUR = 1 | 2 | 3 | 4 | 6 | 8 | 12 | 24
      (if this is the only <SCHED>, this means run job every <HOUR> hours)
        e.g.:
          \@4h  =>  hours=0,4,8,12,16,20 minutes=0
          \@6h  =>  hours=0,6,12,18      minutes=0
          \@8h  =>  hours=0,8,16         minutes=0

    TIME_HHMM
      clock time, 24-hour, formatted 'HH:MM'
      same as: hours=HH minutes=MM

    dow=DAYS_OF_WEEK_LETTERS
      parse DAYS_OF_WEEK_LETERS into <DAY_OF_WEEK>,<DAY_OF_WEEK>...
      same as: days-of-week=<DAY_OF_WEEK>,<DAY_OF_WEEK>...
        DAYS_OF_WEEK_LETTERS
          case-sensitive string of up to 7 characters,
            one for each day of the week to include
          e.g.:   mtwTfsS = every day
                  mtwTf   = weekdays
            m = monday
            t = tuesday
            w = wednesday
            T = thursday
            f = friday
            s = saturday
            S = sunday

    hours=<HOUR>,<HOUR>...
      set hours
    minutes=<MIN>,<MIN> ...
      set minutes
    months=<MONTH>,<MONTH>...
      set months
    days-of-week=<DAY_OF_WEEK>,<DAY_OF_WEEK>...
      set days-of-week
    days-of-month=<DAY_OF_MONTH>,<DAY_OF_MONTH>...
      set days-of-month

  OPTS
    --application=APPLICATION | --app=APPLICATION
      for --add:
        use APPLICATION instead of $APPLICATION_TIMED_CMD or $APPLICATION_ALARM
      for --get-events:
        only list events for APPLICATION
      for --clear:
        only cancel events for APPLICATION
    --app-cmd
      same as: --application=$APPLICATION_TIMED_CMD
    --app-alarm
      same as: --application=$APPLICATION_ALARM

    --alarm
      -use application=$APPLICATION_ALARM instead of $APPLICATION_TIMED_CMD
      -extract <HH> + <MM> and <DAYS_OF_WEEK_LETTERS> from SCHED args
        -fail unless exactly one 'hours' and one 'minutes' is specified
      -add EXTRA_EVENT_ARG entries as in:
        --event-arg=\"createdDate=`date +%s%3N`\" \\
        --event-arg=\"daysOfWeek=<DAYS_OF_WEEK_LETTERS>\" \\
        --event-arg=\"timeOfDayWithSeconds=\$((<HH>*60*60 + <MM>*60))\" \\
        --event-arg=\"maximalTimeoutSnoozeCounter=2\" \\
        --event-arg=\"type=clock\" \\
        --event-arg=\"alarm\" \\
        --event-arg=\"reminder\" \\
        --event-arg=\"boot\" \\
        --event-arg=\"keepAlive\" \\
        --event-arg=\"alignedSnooze\" \\

    --event-arg=EXTRA_EVENT_ARG
      (can be given multiple times)
      when adding events, append EXTRA_EVENT_ARG to semicolon-separated list
        in 'timedclient-t5 -e'
";

sub main(@){
  my $action = $ACTION_GET_CONFIGS;
  my $opts = {
    application    => undef,
    isAlarm        => 0,
    title          => undef,
    shellCmd       => undef,
    onceTick       => undef,
    schedArgs      => {},
    extraEventArgs => [],
  };
  while(@_ > 0){
    my $arg = shift @_;
    if($arg =~ /^(-h|--help)$/){
      print "$USAGE\n";
      exit 0;
    }elsif($arg =~ /^(?:--app|--application)=(.+)$/){
      $$opts{application} = $1;
    }elsif($arg =~ /^(--app-cmd)$/){
      $$opts{application} = $APPLICATION_TIMED_CMD;
    }elsif($arg =~ /^(--app-alarm)$/){
      $$opts{application} = $APPLICATION_ALARM;
    }elsif($arg =~ /^--event-arg=(.+)$/){
      push @{$$opts{extraEventArgs}}, $1;
    }elsif($arg =~ /^(-g|--get)$/){
      $action = $ACTION_GET_CONFIGS;
    }elsif($arg =~ /^(--get-events)$/){
      $action = $ACTION_GET_EVENTS;
    }elsif($arg =~ /^(--clear)$/){
      $action = $ACTION_CLEAR;
    }elsif($arg =~ /^(-a|--add)$/){
      $action = $ACTION_ADD;
    }elsif($arg =~ /^--get-configs$/){
      $action = $ACTION_GET_CONFIGS;
    }elsif($arg =~ /^(-t|--toggle)$/ and @_ > 0){
      $action = $ACTION_TOGGLE_CONFIG;
      $$opts{title} = shift @_;
    }elsif($arg =~ /^--toggle=(.+)$/){
      $action = $ACTION_TOGGLE_CONFIG;
      $$opts{title} = $1;
    }elsif($arg =~ /^(--apply-config)$/){
      $action = $ACTION_APPLY_CONFIG;
    }elsif($arg =~ /^(--alarm)$/){
      $$opts{isAlarm} = 1;
    }elsif($arg =~ /^--title=(.+)$/){
      $$opts{title} = $1;
    }elsif($arg =~ /^--cmd=(.*)$/){
      $$opts{shellCmd} = $1;
    }elsif($arg =~ /^(?:--once|--tick)=(\d+)$/){
      $$opts{onceTick} = $1;
    }elsif($arg =~ /^($SCHED_ARG_REGEX)$/){
      applySchedArg($$opts{schedArgs}, $arg);
    }else{
      die "$USAGE\nERROR: unknown arg '$arg'\n";
    }
  }

  if($action eq $ACTION_GET_EVENTS){
    die "$USAGE\nERROR: cannot specify SCHEDULE for action=$action\n" if %{$$opts{schedArgs}} > 0;
    die "$USAGE\nERROR: cannot specify TITLE for action=$action\n" if defined $$opts{title};
    die "$USAGE\nERROR: cannot specify COMMAND for action=$action\n" if defined $$opts{shellCmd};

    my @cookies;
    if(defined $$opts{application}){
      @cookies = getEventCookiesForApplication($$opts{application});
    }else{
      @cookies = getEventCookiesAll();
    }

    my %eventsByCookie = map {$_ => getTimedCmdEventInfo $_} @cookies;
    my $maxTitleLen = max(map {length $$_{TITLE}} values %eventsByCookie);
    for my $cookie(@cookies){
      my $event = $eventsByCookie{$cookie};
      my $eventFmt;
      if(defined $$event{COMMAND}){
        $eventFmt = sprintf "%4d | %-${maxTitleLen}s | %3s | %s",
          $cookie,
          $$event{TITLE},
          $$event{timingFmt},
          $$event{COMMAND},
        ;
      }else{
        $eventFmt = sprintf "%4d | %-${maxTitleLen}s | %s",
          $cookie,
          $$event{TITLE},
          $$event{timingFmt},
        ;
      }
      print "$eventFmt\n";
    }
  }elsif($action eq $ACTION_CLEAR){
    die "$USAGE\nERROR: cannot specify SCHEDULE for action=$action\n" if %{$$opts{schedArgs}} > 0;
    die "$USAGE\nERROR: cannot specify TITLE for action=$action\n" if defined $$opts{title};
    die "$USAGE\nERROR: cannot specify COMMAND for action=$action\n" if defined $$opts{shellCmd};

    my @cookies;
    if(defined $$opts{application}){
      @cookies = getEventCookiesForApplication($$opts{application});
    }else{
      @cookies = getEventCookiesAll();
    }
    for my $cookie(@cookies){
      run "timedclient-qt5", "--cancel-event", $cookie;
    }
  }elsif($action eq $ACTION_ADD){
    die "$USAGE\nERROR: must specify TITLE for action=$action\n" if not defined $$opts{title};
    my $shellCmd = $$opts{shellCmd};

    my $application;

    if($$opts{isAlarm}){
      $application = $APPLICATION_ALARM;
      if(defined $shellCmd){
        die "$USAGE\nERROR: cannot specify COMMAND for --alarm\n";
      }
      my $hours = $$opts{schedArgs}{$ATT_HOURS} if defined $$opts{schedArgs};
      my $minutes = $$opts{schedArgs}{$ATT_MINUTES} if defined $$opts{schedArgs};
      my $daysOfWeek = $$opts{schedArgs}{$ATT_DAYS_OF_WEEK} if defined $$opts{schedArgs};
      if(not defined $hours or not defined $minutes or @$hours != 1 or @$minutes != 1){
        die "ERROR: must specify exactly one hour and one minute value for --alarm\n";
      }
      my $timeOfDayS = $$hours[0]*60*60 + $$minutes[0]*60;
      my $dowLettersStr = dowNamesArrToLettersStr(@$daysOfWeek) if defined $daysOfWeek;

      push @{$$opts{extraEventArgs}}, "createdDate=" . nowMillis();
      push @{$$opts{extraEventArgs}}, "timeOfDayWithSeconds=$timeOfDayS";
      push @{$$opts{extraEventArgs}}, "daysOfWeek=$dowLettersStr";
      push @{$$opts{extraEventArgs}}, "maximalTimeoutSnoozeCounter=2"; #not implemented in timedclient-qt5 as of 3.6.13-1.8.1
      push @{$$opts{extraEventArgs}}, "type=clock";
      push @{$$opts{extraEventArgs}}, "alarm";
      push @{$$opts{extraEventArgs}}, "reminder";
      push @{$$opts{extraEventArgs}}, "boot";
      push @{$$opts{extraEventArgs}}, "keepAlive";
      push @{$$opts{extraEventArgs}}, "alignedSnooze";
    }else{
      $application = $APPLICATION_TIMED_CMD;
      if(not defined $shellCmd){
        die "$USAGE\nERROR: must specify COMMAND if --alarm is not given\n";
      }
    }

    if(defined $$opts{application}){
      #override APPLICATION
      $application = $$opts{application};
    }

    if(defined $$opts{onceTick} and %{$$opts{schedArgs}} > 0){
      die "ERROR: cannot specify both SCHED and ONCE\n";
    }

    if($$opts{title} !~ /^[a-zA-Z0-9_\-]+$/){
      die "ERROR: TITLE can only contain letters/numbers/underscores/dashes\n";
    }
    if(defined $shellCmd and $shellCmd =~ /'/){
      die "ERROR: COMMAND cannot contain apostrophes (for $EXEC convenience)\n";
    }

    my @actionArgs = defined $shellCmd ? ("whenDue", "runCommand=$shellCmd") : ();
    my @eventArgs = (
      "APPLICATION=$application",
      "TITLE=$$opts{title}",
      @{$$opts{extraEventArgs}},
    );

    my @recurrenceArgs;
    if(defined $$opts{onceTick}){
      print "adding command with ticker=$$opts{onceTick}\n";
      push @eventArgs, "ticker=$$opts{onceTick}";
      @recurrenceArgs = ();
    }else{
      my $sched = {%$SCHED_ALL, %{$$opts{schedArgs}}};

      print "adding command with schedule: " . parseSchedule($sched) . "\n";
      @recurrenceArgs = getScheduleRecurrenceArgs($sched);
    }

    my @cmd = ("timedclient-qt5");
    @cmd = (@cmd, "-a", join(";", @actionArgs)) if @actionArgs > 0;
    @cmd = (@cmd, "-r", join(";", @recurrenceArgs)) if @recurrenceArgs > 0;
    @cmd = (@cmd, "-e", join(";", @eventArgs)) if @eventArgs > 0;

    run @cmd;
  }elsif($action eq $ACTION_GET_CONFIGS){
    die "$USAGE\nERROR: cannot specify SCHEDULE for action=$action\n" if %{$$opts{schedArgs}} > 0;
    die "$USAGE\nERROR: cannot specify TITLE for action=$action\n" if defined $$opts{title};
    die "$USAGE\nERROR: cannot specify COMMAND for action=$action\n" if defined $$opts{shellCmd};
    die "$USAGE\nERROR: cannot specify APPLICATION for action=$action\n" if defined $$opts{application};

    my $conf = readConf($CONF_FILE);

    my @allCookies = getEventCookiesAll();
    my %eventsByCookie = map {$_ => getTimedCmdEventInfo $_} @allCookies;
    my %cookiesByTitle = map {$eventsByCookie{$_}{TITLE} => $_} sort @allCookies;

    my @events = @{$$conf{events}};

    my $maxTitleLen = max(map {length $$_{title}} @events);
    for my $event(@{$$conf{events}}){
      my $cookie = $cookiesByTitle{$$event{title}};
      my $status;
      if(defined $cookie){
        $status = "on";
      }else{
        $status = "off";
        $cookie = "none";
      }
      printf "%-3s | %-${maxTitleLen}s | %4s | %-15s | %5s | %s\n",
        $status,
        $$event{title},
        $cookie,
        $$event{schedArgs},
        ($$event{timeout} ? $$event{timeout} : "-"x5),
        ($$event{type} eq $CONF_TYPE_ALARM ? "<ALARM>" : $$event{cmd}),
      ;
    }
 }elsif($action eq $ACTION_TOGGLE_CONFIG){
    die "$USAGE\nERROR: cannot specify SCHEDULE for action=$action\n" if %{$$opts{schedArgs}} > 0;
    die "$USAGE\nERROR: cannot specify COMMAND for action=$action\n" if defined $$opts{shellCmd};
    die "$USAGE\nERROR: must specify TITLE for action=$action\n" if not defined $$opts{title};
    die "$USAGE\nERROR: cannot specify APPLICATION for action=$action\n" if defined $$opts{application};

    my $conf = readConf($CONF_FILE);
    my $targetConfEvent = undef;
    for my $event(@{$$conf{events}}){
      if($$event{title} eq $$opts{title}){
        $targetConfEvent = $event;
        last;
      }
    }
    if(not defined $targetConfEvent){
      die "ERROR: unknown conf entry title '$$opts{title}'\n";
    }

    my @allCookies = getEventCookiesAll();
    my %eventsByCookie = map {$_ => getTimedCmdEventInfo $_} @allCookies;
    my %cookiesByTitle = map {$eventsByCookie{$_}{TITLE} => $_} sort @allCookies;

    if(defined $cookiesByTitle{$$opts{title}}){
      run "timedclient-qt5", "--cancel-event", $cookiesByTitle{$$opts{title}};
    }else{
      addEventFromConfEntry($targetConfEvent);
    }
  }elsif($action eq $ACTION_APPLY_CONFIG){
    die "$USAGE\nERROR: cannot specify SCHEDULE for action=$action\n" if %{$$opts{schedArgs}} > 0;
    die "$USAGE\nERROR: cannot specify TITLE for action=$action\n" if defined $$opts{title};
    die "$USAGE\nERROR: cannot specify COMMAND for action=$action\n" if defined $$opts{shellCmd};
    die "$USAGE\nERROR: cannot specify APPLICATION for action=$action\n" if defined $$opts{application};
    my $conf = readConf($CONF_FILE);

    print "\nclearing all events\n";
    run $EXEC, "--clear";
    print "\n\n\n";

    print "\nadding conf events\n";
    for my $event(@{$$conf{events}}){
      print "\n";
      addEventFromConfEntry($event);
    }

    print "\n\nall events:\n";
    run $EXEC, "--get-events";
  }else{
    die "ERROR: unknown action $action\n";
  }
}

sub readConf($){
  my ($file) = @_;
  my $conf = {
    events => [],
  };
  if(not -e $file){
    return $conf;
  }

  open my $fh, "<", $file or die "ERROR: could not read $file\n$!\n";
  my @lines = <$fh>;
  close $fh;

  my $schedArgsRegex = "(?:(?:(?:$SCHED_ARG_REGEX)\\s+)*(?:$SCHED_ARG_REGEX))";
  for my $line(@lines){
    next if $line =~ /^\s*(#.*)?$/;
    if($line =~ /^
      \s* alarm \s* =
      \s* (\w+) \s* \|
      \s* ($schedArgsRegex)
      $
    /xi){
      push @{$$conf{events}}, {
        type      => $CONF_TYPE_ALARM,
        title     => $1,
        schedArgs => $2,
        timeout   => undef,
        useDaemon => undef,
        cmd       => undef,
      };
    }elsif($line =~ /
      ^
      \s* cmd \s* =
      \s* ([a-zA-Z0-9_\-]+) \s* \|
      \s* ($schedArgsRegex) \s* \|
      \s* ((?:0|\d+(?:ms|s|m|min|h|d))?) \s* \|
      \s* (true|false) \s* \|
      \s* (\S.*\S)
      \s*
      $
    /xi){
      push @{$$conf{events}}, {
        type      => $CONF_TYPE_CMD,
        title     => $1,
        schedArgs => $2,
        timeout   => $3,
        useDaemon => $4,
        cmd       => $5,
      };
    }else{
      die "ERROR: malformed entry in $CONF_FILE\n$line";
    }
  }

  return $conf;
}

sub addEventFromConfEntry($){
  my ($confEntry) = @_;
  if($$confEntry{type} eq $CONF_TYPE_CMD){
    my $title = $$confEntry{title};
    my @schedArgs = split /\s+/, $$confEntry{schedArgs};
    my $timeout = $$confEntry{timeout};
    my $useDaemon = $$confEntry{useDaemon};
    my $shellCmd = $$confEntry{cmd};

    $timeout = "" if not defined $timeout;

    my @fullCmd;
    if($useDaemon =~ /true/){
      if($timeout !~ /^(0|\d+(ms|s|m|min|h|d))$/){
        die "ERROR: invalid timeout for '$title' conf\n";
      }
      @fullCmd = (
        "udo", "daemon-run",
        "--name=$title", "--timeout=$timeout",
        "--verbose",
        $shellCmd,
      );
    }else{
      if($timeout ne ""){
        die "ERROR: cannot specify timeout with daemon=false for '$title' conf\n";
      }
      @fullCmd = ($shellCmd);
    }

    run $EXEC, "--add", "--title=$title", "--cmd=@fullCmd", @schedArgs;
  }elsif($$confEntry{type} eq $CONF_TYPE_ALARM){
    my $title = $$confEntry{title};
    my @schedArgs = split /\s+/, $$confEntry{schedArgs};
    run $EXEC, "--add", "--alarm", "--title=$title", @schedArgs;
  }else{
    die "ERROR: unknown conf type $$confEntry{type}\n";
  }
}

sub getEventCookiesAll(){
  my $out = readProc "timedclient-qt5", "--list";
  return $out =~ /\d+/g;
}

sub getEventCookiesForApplication($){
  my ($application) = @_;
  my $out = readProc "timedclient-qt5", "--search", "APPLICATION=$application";
  return $out =~ /\d+/g;
}

sub getTimedCmdEventInfo($){
  my ($eventCookie) = @_;
  my @lines = readProcLines "timedclient-qt5", "--get-event=$eventCookie";
  my $okAtts = join "|", qw(APPLICATION TITLE COMMAND USER);
  my $okSchedAtts = join "|", (
    $ATT_HOURS, $ATT_MINUTES, $ATT_MONTHS, $ATT_DAYS_OF_WEEK, $ATT_DAYS_OF_MONTH,
  );

  my $event = {
    schedule => undef,
    scheduleFmt => undef,
    tick => undef,
    tickFmt => undef,
    timingFmt => undef,
  };
  for my $line(@lines){
    if($line =~ /^\s*($okAtts)\s*=\s*'(.+)'$/){
      $$event{$1} = $2;
    }elsif($line =~ /^\s*($okSchedAtts)\s*:\s*(.+)$/){
      my ($att, $val) = ($1, $2);
      my @vals = split /\s+/, $val;
      $$event{schedule} = {} if not defined $$event{schedule};
      $$event{schedule}{$att} = [@vals];
    }elsif($line =~ /^\s*Tick: (\d+) \((.*)\)$/){
      $$event{tick} = $1;
      $$event{tickFmt} = $2;
    }
  }
  if(defined $$event{schedule}){
    $$event{scheduleFmt} = parseSchedule($$event{schedule});
  }

  if(defined $$event{schedule}){
    $$event{timingFmt} = $$event{scheduleFmt};
  }elsif(defined $$event{tick}){
    $$event{timingFmt} = "$$event{tick} ($$event{tickFmt})";
  }

  return $event;
}

sub getScheduleRecurrenceArgs($){
  my ($sched) = @_;
  my @args;

  for my $hour(@{$$sched{$ATT_HOURS}}){
    push @args, "hour=$hour";
  }

  for my $minute(@{$$sched{$ATT_MINUTES}}){
    push @args, "minute=$minute";
  }

  if(arrSameElems($$sched{$ATT_DAYS_OF_MONTH}, $$SCHED_ALL{$ATT_DAYS_OF_MONTH})){
    push @args, "everyDayOfMonth";
  }else{
    for my $dayOfMonth(@{$$sched{$ATT_DAYS_OF_MONTH}}){
      push @args, "dayOfMonth=$dayOfMonth";
    }
  }

  if(arrSameElems($$sched{$ATT_DAYS_OF_WEEK}, $$SCHED_ALL{$ATT_DAYS_OF_WEEK})){
    push @args, "everyDayOfWeek";
  }else{
    for my $dayOfWeek(@{$$sched{$ATT_DAYS_OF_WEEK}}){
      push @args, "dayOfWeek=$dayOfWeek";
    }
  }

  if(arrSameElems($$sched{$ATT_MONTHS}, $$SCHED_ALL{$ATT_MONTHS})){
    push @args, "everyMonth";
  }else{
    for my $month(@{$$sched{$ATT_MONTHS}}){
      my %monthIds = (
        Jan => 2,
        Feb => 3,
        Mar => 4,
        Apr => 5,
        May => 6,
        Jun => 7,
        Jul => 8,
        Aug => 9,
        Sep => 10,
        Oct => 11,
        Nov => 12,
        Dec => undef,
      );
      my $monthId = $monthIds{$month};
      if(not defined $monthId){
        die "ERROR: some ridiculous timed off-by-one bug thinks Jan=2 and Dec=13\n"
          . "this completely prevents adding December, except with everyMonth...\n"
          ;
      }
      push @args, "month=$monthId";
    }
  }
  return @args;
}

sub applySchedArg($$){
  my ($schedArgs, $arg) = @_;

  if($arg =~ /^(days-of-week|dow|months|days-of-month|hours|minutes)=(.+)$/){
    my ($field, $valStr) = ($1, $2);
    my $vals = [split /,/, $valStr];
    if($field =~ /^(days-of-week)$/){
      for my $dayOfWeek(@$vals){
        die "ERROR: malformed day-of-week: $dayOfWeek\n"
          if $dayOfWeek !~ /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun)$/;
      }
      $$schedArgs{$ATT_DAYS_OF_WEEK} = $vals;
    }elsif($field =~ /^(dow)$/){
      $$schedArgs{$ATT_DAYS_OF_WEEK} = [dowLettersStrToNamesArr($valStr)];
    }elsif($field =~ /^(months)$/){
      for my $month(@$vals){
        die "ERROR: malformed month: $month\n"
          if $month !~ /^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)$/;
      }
      $$schedArgs{$ATT_MONTHS} = $vals;
    }elsif($field =~ /^(days-of-month)$/){
      for my $dayOfMonth(@$vals){
        die "ERROR: malformed day-of-month: $dayOfMonth\n"
          if $dayOfMonth !~ /^\d+$/ or $dayOfMonth > 31;
      }
      $$schedArgs{$ATT_DAYS_OF_MONTH} = [map {0+$_} @$vals];
    }elsif($field =~ /^(hours)$/){
      for my $hour(@$vals){
        die "ERROR: malformed hour: $hour\n" if $hour !~ /^\d+$/ or $hour >= 24;
      }
      $$schedArgs{$ATT_HOURS} = [map {0+$_} @$vals];
    }elsif($field =~ /^(minutes)$/){
      for my $min(@$vals){
        die "ERROR: malformed min: $min\n" if $min !~ /^\d+$/ or $min >=60;
      }
      $$schedArgs{$ATT_MINUTES} = [map {0+$_} @$vals];
    }else{
      die "ERROR: malformed sched arg: $arg\n";
    }
  }elsif($arg =~ /^(\d|\d\d):(\d\d)$/){
    my ($h, $m) = ($1, $2);
    $$schedArgs{$ATT_HOURS} = [0+$h];
    $$schedArgs{$ATT_MINUTES} = [0+$m];
  }elsif($arg =~ /^@(\d+m)$/){
    my $factor = 0+$1 if $arg =~ /(\d+)/;
    if(not defined $factor or $factor !~ /^(1|2|3|4|5|6|10|12|15|20|30|60)$/){
      die "ERROR: <MIN>m can only accept divisors of 60\n";
    }
    $$schedArgs{$ATT_MINUTES} = filterByDivisible $factor, $$SCHED_ALL{$ATT_MINUTES};
  }elsif($arg =~ /^@(\d+h)$/){
    my $factor = 0+$1 if $arg =~ /(\d+)/;
    if(not defined $factor or $factor !~ /^(1|2|3|4|6|8|12)$/){
      die "ERROR: <HOUR>h can only accept divisors of 24\n";
    }
    $$schedArgs{$ATT_HOURS} = filterByDivisible $factor, $$SCHED_ALL{$ATT_HOURS};
    $$schedArgs{$ATT_MINUTES} = [0];
  }else{
    die "ERROR: unknown SCHED arg $arg\n";
  }
}

sub parseSchedule($){
  my ($schedule) = @_;
  my $hr = $$schedule{$ATT_HOURS};
  my $min = $$schedule{$ATT_MINUTES};
  my $isAllHr = arrSameElems($hr, $$SCHED_ALL{$ATT_HOURS});
  my $isAllMin = arrSameElems($min, $$SCHED_ALL{$ATT_MINUTES});

  my @schedArgs;
  if(@schedArgs == 0 and @$min == 1){
    for my $hrFactor(qw(1 2 3 4 6 8 12 24)){
      my $factorHrs = filterByDivisible $hrFactor, $$SCHED_ALL{$ATT_HOURS};
      if(arrSameElems($hr, $factorHrs)){
        push @schedArgs, "${hrFactor}h";
        push @schedArgs, "minutes=$$min[0]" if $$min[0] != 0;
        last;
      }
    }
  }

  if(@schedArgs == 0 and $isAllHr){
    for my $minFactor(qw(1 2 3 4 5 6 10 12 15 20 30)){
      my $factorMins = filterByDivisible $minFactor, $$SCHED_ALL{$ATT_MINUTES};
      if(arrSameElems($min, $factorMins)){
        push @schedArgs, "${minFactor}m";
        last;
      }
    }
  }

  if(@schedArgs == 0){
    if(@$hr == 1 and @$min == 1){
      push @schedArgs, sprintf("%02d:%02d", $$hr[0], $$min[0]);
    }else{
      push @schedArgs, sprintf("hours=%s", join(",", @$hr)) if not $isAllHr;
      push @schedArgs, sprintf("minutes=%s", join(",", @$min)) if not $isAllMin;
    }
  }

  if(not arrSameElems($$schedule{$ATT_DAYS_OF_WEEK}, $$SCHED_ALL{$ATT_DAYS_OF_WEEK})){
    push @schedArgs, sprintf("dow=%s", dowNamesArrToLettersStr(@{$$schedule{$ATT_DAYS_OF_WEEK}}));
  }
  if(not arrSameElems($$schedule{$ATT_MONTHS}, $$SCHED_ALL{$ATT_MONTHS})){
    push @schedArgs, sprintf("months=%s", join(",", @{$$schedule{$ATT_MONTHS}}));
  }
  if(not arrSameElems($$schedule{$ATT_DAYS_OF_MONTH}, $$SCHED_ALL{$ATT_DAYS_OF_MONTH})){
    push @schedArgs, sprintf("days-of-month=%s", join(",", @{$$schedule{$ATT_DAYS_OF_MONTH}}));
  }

  return "@schedArgs";
}

sub dowLettersStrToNamesArr($){
  my ($dowLettersStr) = @_;
  my %okLetters = map {$_ => 1} split //, $dowLettersStr;
  for my $letter(sort keys %okLetters){
    die "ERROR: unknown DOW letter $letter\n" if not defined $DOW_LETTER_TO_NAME{$letter};
  }
  return map {$DOW_LETTER_TO_NAME{$_}} grep {defined $okLetters{$_}} @DOW_LETTER_ORDER
}
sub dowNamesArrToLettersStr(@){
  my (@dowNamesArr) = @_;
  my %okNames = map {$_ => 1} @dowNamesArr;
  for my $name(sort keys %okNames){
    die "ERROR: unknown DOW name $name\n" if not defined $DOW_NAME_TO_LETTER{$name};
  }
  return join "", map {$DOW_NAME_TO_LETTER{$_}} grep {defined $okNames{$_}} @DOW_NAME_ORDER;
}

sub filterByDivisible($$){
  my ($factor, $arr) = @_;
  return [grep {$_ % $factor == 0} @$arr];
}

sub arrSameElems($$){
  my ($arrRef1, $arrRef2) = @_;
  return 0 if @$arrRef1 != @$arrRef2;

  my @arr1 = sort @$arrRef1;
  my @arr2 = sort @$arrRef2;
  for(my $i=0; $i<@arr1; $i++){
    if($arr1[$i] ne $arr2[$i]){
      return 0;
    }
  }
  return 1;
}

sub run(@){
  print "@_\n";
  system @_;
  die "ERROR: \"@_\" failed\n" if $? != 0;
}
sub readProc(@){
  return join '', readProcLines @_;
}
sub readProcLines(@){
  open CMD, "-|", @_ or die "ERROR: could not run \"@_\"\n$!\n";
  my @lines = <CMD>;
  close CMD;
  die "ERROR: \"@_\" failed\n" if $? != 0;
  return @lines;
}

sub nowMillis(){
  return int(time * 1000.0 + 0.5);
}

&main(@ARGV);
