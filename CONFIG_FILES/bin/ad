#!/usr/bin/perl
use strict;
use warnings;
use File::Basename qw(basename);

sub lxcShell($@);
sub getApksForPrefix($);
sub getRes();
sub parseScreenDimArg($$);
sub isExecOnPath($);

my $EXEC = basename $0;

my $APK_DIR = "/media/sdcard/phone/apks-aliendalvik";
my %SHELL_ENV_VARS = (
  ANDROID_DATA         => "/data",
  ANDROID_RUNTIME_ROOT => "/apex/com.android.runtime",
  ANDROID_TZDATA_ROOT  => "/apex/com.android.tzdata",
);
my $SHELL_ENV_VARS_SH_FMT = join " ", map{"$_=$SHELL_ENV_VARS{$_}"}
  sort keys %SHELL_ENV_VARS;
my $SHELL_ENV_VARS_USAGE_FMT = join " \\\n            ", map{"$_=$SHELL_ENV_VARS{$_}"}
  sort keys %SHELL_ENV_VARS;

my $DEFAULT_ATTACH_CMD = "appsupport-attach";

my $USAGE = "Usage:
  $EXEC -h|--help
    show this message

  $EXEC start|--start
  $EXEC stop|--stop
  $EXEC restart|--restart
    run: sudo systemctl start|stop|restart aliendalvik

  $EXEC
  $EXEC -x|x
  $EXEC --shell|shell
    run: sudo LXC_ATTACH_CMD --name=aliendalvik

  $EXEC -x|x CMD_ARG CMD_ARG
    run: sudo LXC_ATTACH_CMD --name=aliendalvik -- CMD_ARG CMD_ARG CMD_ARG..

  $EXEC CMD_ARG CMD_ARG...
  $EXEC --shell|shell CMD_ARG CMD_ARG...
    run: sudo LXC_ATTACH_CMD --name=aliendalvik -- sh -c '
            $SHELL_ENV_VARS_USAGE_FMT \\
            CMD_ARG CMD_ARG CMD_ARG..'

  $EXEC res|--res
    -get window info as in: $EXEC --shell dumpsys window
    -parse DisplayInfo.real
      e.g.: DisplayInfo{app 2394 x 1080, real 2520 x 1080, ... }
    -print WIDTHxHEIGHT

  $EXEC tap|--tap XPOS YPOS
  $EXEC --tap=XPOSxYPOS
    run 'input tap' with args as if device is in portrait mode
      (rotate args if device is in landscape)
    -get screen <SCREEN_WIDTH> and <SCREEN_HEIGHT> as in $EXEC --get-res
    -calculate screen-percent if <XPOS> is 'X_PCT%'
      X_PX = <X_PCT> * MIN(<SCREEN_WIDTH>, <SCREEN_HEIGHT>)
    -calculate screen-percent if <YPOS> is 'Y_PCT%'
      Y_PX = <Y_PCT> * MAX(<SCREEN_WIDTH>, <SCREEN_HEIGHT>)
    -convert portrait tap for current orientation:
      -if landscape mode (SCREEN_WIDTH > SCREEN_HEIGHT):
        ROTATED_X_PX = Y_PX
        ROTATED_Y_PX = SCREEN_HEIGHT - X_PX
      -otherwise:
        ROTATED_X_PX = X_PX
        ROTATED_Y_PX = Y_PX
    -run: $EXEC --shell input tap ROTATED_X_PX ROTATED_Y_PX

    XPOS
      position along narrow edge, measured from top-left corner in portrait mode
      can be integer number of px, or real number followed by '%'
    YPOS
      position along wide edge, measured from top-left corner in portrait mode
      can be integer number of px, or real number followed by '%'

  $EXEC orient|--orient ORIENT_ARG
  $EXEC --orient=ORIENT_ARG
    -if ORIENT_ARG = 'auto':
      ACCEL_VAL=1
      USER_VAL=0
    -if ORIENT_ARG = 'landscape':
      ACCEL_VAL=0
      USER_VAL=1
    -if ORIENT_ARG = 'portrait':
      ACCEL_VAL=0
      USER_VAL=0
    -run:
      $EXEC --shell content insert --uri content://settings/system \\
        --bind name:s:accelerometer_rotation --bind value:i:<ACCEL_VAL>
    -run:
      $EXEC --shell content insert --uri content://settings/system \\
        --bind name:s:user_rotation --bind value:i:<USER_VAL>

  $EXEC -i|-i|--install|install APK_FILE APK_FILE...
  $EXEC --install=APK_FILE
    run: apkd-install-preload APK_FILE APK_FILE...
         apkd-install APK_FILE APK_FILE...

    APK_FILE
      an .apk file, OR a prefix of .apk files in $APK_DIR
      e.g.: /tmp/abc.apk  => /tmp/abc.apk
            coolreader-   => $APK_DIR/coolreader-*.apk

  $EXEC -u|--uninstall|uninstall APK_FILE APK_FILE...
    for each APK_FILE:
      get the PACKAGE_NAME with `apk-info --package`
      run: $EXEC pm uninstall PACKAGE_NAME

  $EXEC -l|l|--launch|launch|--launch-intent|launch-intent INTENT
  $EXEC --launch=INTENT
  $EXEC --launch-intent=INTENT
    -parse INTENT into: PKG_NAME/ACTIVITY
      -if ACTIVITY starts with a '.', PKG_NAME will be prepended
    -run: apkd-launcher PKG_NAME.apk PKG_NAME/ACTIVITY
    e.g.: $EXEC -l org.coolreader/.CoolReader
          => apkd-launcher org.coolreader.apk org.coolreader/org.coolreader.CoolReader

  $EXEC settings|--settings
    same as: $EXEC --intent=com.android.settings/.Settings

  LXC_ATTACH_CMD
    appsupport-attach if it exists
    lxc-attach otherwise
";

my $MODE_SHELL = "shell";
my $MODE_RES = "res";
my $MODE_TAP = "tap";
my $MODE_ORIENT = "orient";
my $MODE_INSTALL = "install";
my $MODE_UNINSTALL = "uninstall";
my $MODE_LAUNCH = "launch";

sub main(@){
  my $mode = $MODE_SHELL;
  my @cmdArgs;
  my @apkFileArgs;
  my $intent;
  my $shellEnvWrapper = 1;
  my ($tapXpos, $tapYpos);
  my $orientArg;
  for(my $i=0; $i<@_; $i++){
    my $arg = $_[$i];
    my $isFirstArg = $i == 0 ? 1 : 0;
    my $isLastArg = $i == $#_ ? 1 : 0;
    if($isFirstArg and $arg =~ /^(-h|--help)$/){
      print $USAGE;
      exit 0;
    }elsif($isFirstArg and $arg =~ /^(?:--)?(start|stop|restart)$/ and $isLastArg){
      my $cmd = $1;
      exec "sudo", "systemctl", $cmd, "aliendalvik";
    }elsif($isFirstArg and $arg =~ /^(-x|x)$/){
      $mode = $MODE_SHELL;
      $shellEnvWrapper = 0;
    }elsif($isFirstArg and $arg =~ /^(--shell|shell)$/){
      $mode = $MODE_SHELL;
      $shellEnvWrapper = 1;
    }elsif($isFirstArg and $arg =~ /^(res|-res)$/){
      $mode = $MODE_RES;
    }elsif($isFirstArg and $arg =~ /^(tap|--tap)$/ and $i == $#_-2){
      $mode = $MODE_TAP;
      ($tapXpos, $tapYpos) = ($_[++$i], $_[++$i]);
    }elsif($isFirstArg and $arg =~ /^--tap=(.+)x(.+)$/){
      $mode = $MODE_TAP;
      ($tapXpos, $tapYpos) = ($1, $2);
    }elsif($isFirstArg and $arg =~ /^(orient|--orient)$/ and $i == $#_-1){
      $mode = $MODE_ORIENT;
      $orientArg = $_[++$i];
    }elsif($isFirstArg and $arg =~ /^--orient=(.+)$/){
      $mode = $MODE_ORIENT;
      $orientArg = $1;
    }elsif($isFirstArg and $arg =~ /^(-i|i|--install|install)$/){
      $mode = $MODE_INSTALL;
    }elsif($isFirstArg and $arg =~ /^(--install)=(.+)$/){
      $mode = $MODE_INSTALL;
      push @apkFileArgs, $2;
    }elsif($isFirstArg and $arg =~ /^(-u|u|--uninstall|uninstall)$/){
      $mode = $MODE_UNINSTALL;
    }elsif($isFirstArg and $arg =~ /^(--uninstall)=(.+)$/){
      $mode = $MODE_UNINSTALL;
      push @apkFileArgs, $2;
    }elsif($isFirstArg and $arg =~ /^(-l|l|--launch|launch|--launch-intent|launch-intent)$/){
      $mode = $MODE_LAUNCH;
    }elsif($isFirstArg and $arg =~ /^(--launch|--launch-intent)=(.+)$/){
      $mode = $MODE_LAUNCH;
      $intent = $2;
    }elsif($isFirstArg and $arg =~ /^(settings|--settings)$/){
      $mode = $MODE_LAUNCH;
      $intent = 'com.android.settings/.Settings';
    }elsif($mode eq $MODE_SHELL){
      push @cmdArgs, $arg;
    }elsif($mode =~ /^($MODE_INSTALL|$MODE_UNINSTALL)$/){
      if(-f $arg){
        push @apkFileArgs, $arg;
      }else{
        my @apkPrefixFiles = getApksForPrefix($arg);
        if(@apkPrefixFiles == 0){
          die "$USAGE\nERROR: no APK files found for prefix $arg\n";
        }
        print "$arg => \n" . join '', map {"  $_\n"} @apkPrefixFiles;
        @apkFileArgs = (@apkFileArgs, @apkPrefixFiles);
      }
    }elsif($mode eq $MODE_LAUNCH and not defined $intent){
      $intent = $arg;
    }else{
      die "$USAGE\nERROR: unknown arg '$arg'\n";
    }
  }

  if($mode eq $MODE_SHELL){
    lxcShell($shellEnvWrapper, @cmdArgs);
  }elsif($mode eq $MODE_INSTALL){
    die "$USAGE\nError: no APK_FILE to install\n" if @apkFileArgs == 0;
    my $envArgs = "DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/100000/dbus/user_bus_socket";
    system "sudo", "sh", "-c", "$envArgs apkd-install-preload @apkFileArgs";
    system "sudo", "sh", "-c", "$envArgs apkd-install @apkFileArgs";
  }elsif($mode eq $MODE_UNINSTALL){
    die "$USAGE\nError: no APK_FILE to uninstall\n" if @apkFileArgs == 0;
    for my $apkFile(@apkFileArgs){
      my $pkgName = `apk-info --package $apkFile`;
      chomp $pkgName;
      my @cmd = ("pm", "uninstall", $pkgName);
      print "@cmd\n";
      lxcShell 1, @cmd;
    }
  }elsif($mode eq $MODE_RES){
    my ($screenX, $screenY) = getRes();
    print "${screenX}x${screenY}\n";
  }elsif($mode eq $MODE_TAP){
    my ($screenX, $screenY) = getRes();
    my $isLandscape;
    my ($minDim, $maxDim);
    if(not defined $screenX or not defined $screenY){
      $isLandscape = 0;
      ($minDim, $maxDim) = (undef, undef);
    }else{
      $isLandscape = $screenX > $screenY;
      ($minDim, $maxDim) = $isLandscape ? ($screenY, $screenX) : ($screenX, $screenY);
    }

    my $xPx = parseScreenDimArg($tapXpos, $minDim);
    my $yPx = parseScreenDimArg($tapYpos, $maxDim);

    my $realX = $isLandscape ? $yPx : $xPx;
    my $realY = $isLandscape ? $screenY - $xPx : $yPx;

    print "tapping ${realX}x${realY}\n";
    lxcShell 1, "input", "tap", $realX, $realY;
  }elsif($mode eq $MODE_ORIENT){
    my ($accelVal, $userVal);
    if($orientArg eq "auto"){
      ($accelVal, $userVal) = (1, 0);
    }elsif($orientArg eq "portrait"){
      ($accelVal, $userVal) = (0, 0);
    }elsif($orientArg eq "landscape"){
      ($accelVal, $userVal) = (0, 1);
    }

    lxcShell 1, ("content", "insert", "--uri", "content://settings/system",
      "--bind", "name:s:accelerometer_rotation", "--bind", "value:i:$accelVal");
    lxcShell 1, ("content", "insert", "--uri", "content://settings/system",
      "--bind", "name:s:user_rotation", "--bind", "value:i:$userVal");
  }elsif($mode eq $MODE_LAUNCH){
    die "ERROR: missing intent\n" if not defined $intent;
    my ($pkgName, $activity);
    if($intent =~ /^(.+)\/(.+)$/){
      ($pkgName, $activity) = ($1, $2);
      if($activity =~ /^\./){
        #this is NOT implemented by apkd-launcher, apparently
        $activity = "$pkgName$activity";
      }
    }else{
      die "ERROR: malformed intent (must be PKG_NAME/ACTIVITY)\n";
    }
    my $apk = "$pkgName.apk";
    my @cmd = ("apkd-launcher", $apk, "$pkgName/$activity");
    exec @cmd;
  }else{
    die "ERROR: unknown mode $mode\n";
  }
}

sub lxcShell($@){
  my ($shellEnvWrapper, @shellCmd) = @_;
  my $useAppSupportAttach = isExecOnPath("appsupport-attach");

  my @cmd;
  if($useAppSupportAttach){
    @cmd = ("sudo", "appsupport-attach");
  }else{
    @cmd = ("sudo", "lxc-attach", "-q", "--name=aliendalvik", "--");
  }

  if(@shellCmd > 0 and $shellEnvWrapper){
    @cmd = (@cmd, "sh", "-c", "$SHELL_ENV_VARS_SH_FMT @shellCmd");
    print "@cmd\n";
  }else{
    @cmd = (@cmd, @shellCmd);
  }
  system @cmd;
}

sub getApksForPrefix($){
  my ($prefix) = @_;
  my @files = glob "$APK_DIR/$prefix*";
  @files = grep {/\.apk$/i} grep {-f $_} @files;
  return @files;
}

sub getRes(){
  my $out = `$EXEC --shell dumpsys window`;
  if($out =~ /DisplayInfo.*real (\d+) x (\d+)/){
    return ($1, $2);
  }
  return (undef, undef);
}

sub parseScreenDimArg($$){
  my ($arg, $screenDimSize) = @_;
  if($arg =~ /^(\d+)$/){
    return $1;
  }elsif($arg =~ /^(\d+|\d*\.\d+)%$/){
    die "ERROR: missing screen dimension\n" if not defined $screenDimSize;
    return int($1/100.0*$screenDimSize + 0.5);
  }
}

sub isExecOnPath($){
  my ($exec) = @_;
  my $out = `which $exec 2>/dev/null`;
  if($out =~ /^\/.*$exec$/){
    return 1;
  }else{
    return 0;
  }
}

&main(@ARGV);
