#!/usr/bin/perl
use strict;
use warnings;
use Cwd qw(abs_path);
use File::Basename qw(basename);
use Time::HiRes qw(time);

sub initAndroid($);
sub startDbus();
sub stopDbus();
sub restartDbus($);
sub sendDbusStartStop($);
sub systemctlCmd($);
sub waitForAndroidEvents($@);
sub isAliendalvikRunning($);
sub launchIntent($);
sub extractLaunchIntent($$$);
sub readIntentFromPkgName($$);
sub readSdcardsConf();
sub isSdcardsMounted($$);
sub isUUIDMounted($$);
sub isHomeMounted($);
sub lxcWrapCmd($@);
sub lxcShell($@);
sub lxcReadProc($@);
sub getApksForPrefix($);
sub getRes();
sub parseScreenDimArg($$);
sub nowMillis();

my $EXEC = basename $0;

my $SDCARDS_CONF_FILE = "/etc/sdcards.conf";
my $SAILFISH_HOME_MAPPER_BLOCK_DEV = "/dev/mapper/sailfish-home";

my $APK_DIR = "/media/sdcard/phone/apks-aliendalvik";
my %SHELL_ENV_VARS = (
  ANDROID_DATA         => "/data",
  ANDROID_RUNTIME_ROOT => "/apex/com.android.runtime",
  ANDROID_TZDATA_ROOT  => "/apex/com.android.tzdata",
);
my $SHELL_ENV_VARS_SH_FMT = join " ", map{"$_=$SHELL_ENV_VARS{$_}"}
  sort keys %SHELL_ENV_VARS;
my $SHELL_ENV_VARS_USAGE_FMT = join " \\\n            ", map{"$_=$SHELL_ENV_VARS{$_}"}
  sort keys %SHELL_ENV_VARS;

my $USER = "nemo";
my $CONTAINER_NAME = $USER;
my @LXC_PATHS = qw(
  /tmp/appsupport
  /var/lib/lxc
);

my $SYSTEMD_SERVICE = "appsupport";

my $DEFAULT_WAIT_TIMEOUT_SECONDS = 60;

my $EVENT_ANDROID_START = "start";
my $EVENT_ANDROID_STOP = "stop";
my $EVENT_ANDROID_MOUNT = "mount";

my @MEDIA_EXTS = qw(
  jpg jpeg png gif mpo webm
  mp3 flac ogg m4a wma wav
  avi m2ts mts mov mkv mpeg mpg mp4
);
my $OK_MEDIA_EXTS = join "|", @MEDIA_EXTS;

my $DBUS_ENV = "DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/100000/dbus/user_bus_socket";

my $DBUS_DEST_SERVICE_NAME = "com.jolla.apkd.control";
my $DBUS_PATH = "/com/jolla/apkd";
my $DBUS_CONTROL_METHOD = "com.jolla.apkd.control.controlService";

my @SHELL_CMD_FAVORITES = qw(
  am cmd echo env find logcat ls mount pm ps sh stat test time timeout which whoami
);
my $SHELL_CMD_FAVORITES_REGEX = join("|", @SHELL_CMD_FAVORITES);

my $USAGE = "Usage:
  $EXEC -h|--help
    show this message

  $EXEC [OPTS] --start|start
    call system dbus method $DBUS_CONTROL_METHOD true $USER
  $EXEC [OPTS] --stop|stop
    call system dbus method $DBUS_CONTROL_METHOD false $USER
  $EXEC [OPTS] --restart|restart
    -stop android as in: $EXEC --stop
    -wait for android to be stopped as in:
      $EXEC --wait --events=$EVENT_ANDROID_STOP
      (see --timeout and --events)
    -sleep 3s
    -start android as in: $EXEC --stop

  $EXEC [OPTS] --systemctl|systemctl SERVICE_CMD
    run as $USER: systemctl --user SERVICE_CMD $SYSTEMD_SERVICE

  $EXEC [OPTS] --init|init
    -ensure aliendalvik is running and sdcards+home are mounted
      -if not running, start it
      -wait up to ${DEFAULT_WAIT_TIMEOUT_SECONDS}s for it to start and mount sdcards+home
        (see --timeout and --events)
    -retry check+start+wait one more time, again up to ${DEFAULT_WAIT_TIMEOUT_SECONDS}s
    -if aliendalvik is running with sdcards+home mounted:
      -exit with status 0
    -if timeout occurs:
      -exit with status 1
    similar to:
      $EXEC --check-running || $EXEC start ; $EXEC --wait
      $EXEC --check-running || $EXEC start ; $EXEC --wait

  $EXEC [OPTS] --app|app APP_NAME LAUNCH_ARG
    same as: $EXEC --init --notify=APP_NAME && $EXEC --launch LAUNCH_ARG
    (see --timeout and --events)

  $EXEC [OPTS]
    same as: $EXEC --shell

  $EXEC [OPTS] -x|x
  $EXEC [OPTS] --lxc|lxc
    run: sudo LXC_ATTACH_CMD

  $EXEC [OPTS] -x|x CMD_ARG CMD_ARG..
  $EXEC [OPTS] --lxc|lxc CMD_ARG CMD_ARG..
    run: sudo LXC_ATTACH_CMD -- CMD_ARG CMD_ARG..

  $EXEC [OPTS] --shell|shell
    same as: $EXEC --lxc
  $EXEC [OPTS] --shell|shell CMD_ARG CMD_ARG..
    same as: $EXEC --lxc sh -c '
               $SHELL_ENV_VARS_USAGE_FMT \\
               CMD_ARG CMD_ARG..'

  $EXEC [OPTS] SHELL_COMMAND_FAVORITE [CMD_ARG CMD_ARG ..]
    same as: $EXEC --shell SHELL_COMMAND_FAVORITE CMD_ARG CMD_ARG..
    SHELL_COMMAND_FAVORITE is one of:
      @SHELL_CMD_FAVORITES

  $EXEC [OPTS] --fuse|fuse
  $EXEC [OPTS] --remount-fuse|remount-fuse
    remount all fuse filesystems in android container
    fixes out-of-sync /storage mounts for home+android_storage and external sdcards
    (and symlinks like /sdcard)
      -same as: $EXEC --shell 'mount -a -t fuse -o remount'

  $EXEC [OPTS] --res|res
    -get window info as in: $EXEC --shell dumpsys window
    -parse DisplayInfo.real
      e.g.: DisplayInfo{app 2394 x 1080, real 2520 x 1080, ... }
    -print WIDTHxHEIGHT

  $EXEC [OPTS] --tap|tap XPOS YPOS
  $EXEC [OPTS] --tap|tap XPOSxYPOS
    run 'input tap' with args as if device is in portrait mode
      (rotate args if device is in landscape)
    -get screen <SCREEN_WIDTH> and <SCREEN_HEIGHT> as in $EXEC --get-res
    -calculate screen-percent if <XPOS> is 'X_PCT%'
      X_PX = <X_PCT> * MIN(<SCREEN_WIDTH>, <SCREEN_HEIGHT>)
    -calculate screen-percent if <YPOS> is 'Y_PCT%'
      Y_PX = <Y_PCT> * MAX(<SCREEN_WIDTH>, <SCREEN_HEIGHT>)
    -convert portrait tap for current orientation:
      -if landscape mode (SCREEN_WIDTH > SCREEN_HEIGHT):
        ROTATED_X_PX = Y_PX
        ROTATED_Y_PX = SCREEN_HEIGHT - X_PX
      -otherwise:
        ROTATED_X_PX = X_PX
        ROTATED_Y_PX = Y_PX
    -run: $EXEC --shell input tap ROTATED_X_PX ROTATED_Y_PX

    XPOS
      position along narrow edge, measured from top-left corner in portrait mode
      can be integer number of px, or real number followed by '%'
    YPOS
      position along wide edge, measured from top-left corner in portrait mode
      can be integer number of px, or real number followed by '%'

  $EXEC [OPTS] --orient|orient ORIENT_ARG
    run:
      $EXEC settings put system accelerometer_rotation ACCEL_VAL
      $EXEC settings put system user_rotation USER_VAL
    (both are run twice because sometimes 'inverted' is ignored)

    ORIENT_ARG
      dynamic | auto | none | d | a | n =  ACCEL_VAL=1   USER_VAL=0
      portrait | p | 0                  =  ACCEL_VAL=0   USER_VAL=0
      landscape | l | 1                 =  ACCEL_VAL=0   USER_VAL=1
      portrait-inverted | pi | 2        =  ACCEL_VAL=0   USER_VAL=2
      landscape-inverted | li | 3       =  ACCEL_VAL=0   USER_VAL=3

  $EXEC [OPTS] --view|view MEDIA_FILE [MEDIA_FILE MEDIA_FILE ..]
    -get TYPE with: file -b --mime-type MEDIA_FILE
    -calculate ANDROID_MEDIA_FILE:
      -take absolute path of MEDIA_FILE
      -replace prefix: '/home/nemo/android_storage' with '/sdcard'
      -replace prefix: '/media/sdcard/phone' with '/sdcard/SDCARD'
    -run: $EXEC am start android.intent.action.VIEW -d file://ANDROID_MEDIA_FILE

  $EXEC [OPTS] MEDIA_FILE_WITH_EXT [MEDIA_FILE MEDIA_FILE ..]
    same as: $EXEC --view MEDIA_FILE_WITH_EXT MEDIA_FILE MEDIA_FILE
    MEDIA_FILE_WITH_EXT must exist and end with extension:
      @MEDIA_EXTS

  $EXEC [OPTS] -i|i APK_FILE_ARG APK_FILE_ARG..
  $EXEC [OPTS] --install|install APK_FILE_ARG APK_FILE_ARG..
    -get list of APK_FILEs from APK_FILE_ARGs
      -for each APK_FILE_ARG:
        -if APK_FILE_ARG is a file, use as APK_FILE
        -if APK_FILE_ARG is a prefix of files in $APK_DIR/
          -add all matching files as APK_FILE
        e.g.: '/tmp/abc.apk'  => /tmp/abc.apk
              'coolreader-'   => $APK_DIR/coolreader-*.apk
    run: apkd-install-preload -i $CONTAINER_NAME APK_FILE APK_FILE..
         apkd-install -i $CONTAINER_NAME APK_FILE APK_FILE..

  $EXEC [OPTS] -u|u APK_FILE_ARG APK_FILE_ARG..
  $EXEC [OPTS] --uninstall|uninstall APK_FILE_ARG APK_FILE_ARG..
    -get APK_FILEs as in --install
    -for each APK_FILE:
      -get the PACKAGE_NAME with `apk-info --package APK_FILE`
      -same as: $EXEC --shell 'pm uninstall PACKAGE_NAME'

  $EXEC [OPTS] -l|l LAUNCH_ARG
  $EXEC [OPTS] --launch|launch LAUNCH_ARG
    -if LAUNCH_ARG matches INTENT formatted '*.*.*/*':
      -same as: $EXEC --launch-intent INTENT
    -if LAUNCH_ARG matches PKG_NAME formatted '*.*.*':
      -same as: $EXEC --launch-pkg PKG_NAME

  $EXEC [OPTS] --launch-intent|launch-intent INTENT
    -parse INTENT into: PKG_NAME/ACTIVITY
      -if ACTIVITY starts with a '.', PKG_NAME will be prepended
    -run: apkd-launcher PKG_NAME.apk PKG_NAME/ACTIVITY
    e.g.: $EXEC --launch-intent org.coolreader/.CoolReader
          => apkd-launcher org.coolreader.apk org.coolreader/org.coolreader.CoolReader

  $EXEC [OPTS] --launch-pkg|launch-pkg PKG_NAME
    -extract INTENT using package name:
      $EXEC --shell cmd package resolve-activity --brief PKG_NAME
    -same as: $EXEC --launch-intent INTENT

  $EXEC [OPTS] --settings|settings
    same as: $EXEC --launch-intent com.android.settings/.Settings

  $EXEC [OPTS] -w|w TIMEOUT_SECONDS [--events=EVENTS_CSV]
  $EXEC [OPTS] --wait|wait TIMEOUT_SECONDS [--events=EVENTS_CSV]
    same as: $EXEC --wait --timeout=TIMEOUT_SECONDS --events=EVENTS_CSV

  $EXEC [OPTS] -w|w [--timeout=TIMEOUT_SECONDS] [--events=EVENTS_CSV]
  $EXEC [OPTS] --wait|wait [--timeout=TIMEOUT_SECONDS] [--events=EVENTS_CSV]
    wait until android events occur
    default is android started and sdcards+home mounted)
         e.g.: $EXEC --start && $EXEC --wait 30 && echo OK || echo FAIL
    -parse EVENTS_CSV into EVENTS
         EVENTS = '$EVENT_ANDROID_START', '$EVENT_ANDROID_STOP', '$EVENT_ANDROID_MOUNT'
      -default is '$EVENT_ANDROID_START,$EVENT_ANDROID_MOUNT'
    -every 1s, check if *all* event conditions are met:
      -check each event given, in order
        $EVENT_ANDROID_START  = android is running
          as in: `$EXEC --check-running`
        $EVENT_ANDROID_STOP   = android is NOT running
          as in: `sh -c '$EXEC --check-running && exit 1 || exit 0'`
        $EVENT_ANDROID_MOUNT  = sdcards+home are mounted
          as in: `$EXEC --check-sdcards`
      -if *all* event conditions are met:
        -exit with exit code 0
      -if TIMEOUT_SECONDS has transpired:
        -print error message
        -exit with exit code 1
      -otherwise:
        sleep for 1s and retry

  $EXEC [OPTS] --check-running|check-running
    check if aliendalvik is running with `LXC_ATTACH_CMD`
    run: `LXC_ATTACH_CMD echo ok 2>/dev/null`
      -if response is ok, exit with exit code 0
      -otherwise, print error message and exit with exit code 1

  $EXEC [OPTS] --check-sdcard|check-sdcard
  $EXEC [OPTS] --check-sdcards|check-sdcards
    check if sailfish home and android sdcards in /etc/sdcards.conf are mounted
      -parse $SDCARDS_CONF_FILE
      -extract UUID '<NAME>.uuid' of any sdcard with android true '<NAME>.android=true'
      -extract UUID of $SAILFISH_HOME_MAPPER_BLOCK_DEV (fails if none found)
      -for each UUID:
        -ensure that /storage/<UUID> exists and is a mountpoint
      -if all are mounted, exit with exit code 0
      -otherwise, print error message and exit with exit code 1

  OPTS
    -q | --quiet
      do not print shell commands before running them (this is the default)
    -v | --verbose
      print shell commands before running them
    --timeout=TIMEOUT_SECONDS
      timeout in seconds when waiting for android events in --wait/--init/--app/--restart
    --events=EVENTS_CSV
      list of events to include when waiting for android events in --wait/--init/--app
        -each event must have its conditions met before waiting is filled
        NOTE: ignored by --restart, always uses $EVENT_ANDROID_STOP
      default: --events=$EVENT_ANDROID_START,$EVENT_ANDROID_MOUNT
        EVENTS_CSV = EVENT,EVENT,EVENT
        EVENT      = one of $EVENT_ANDROID_START,$EVENT_ANDROID_STOP,$EVENT_ANDROID_MOUNT
      e.g.: `ad stop && ad --wait --events=stop` to ensure android is not running
    --skip-mount
      skip checking sdcards+home mounted during --wait
      same as: --events=$EVENT_ANDROID_START
    -n MSG
    --notify MSG
    --notify=MSG
      send notifications during --wait (and --init)
      prefix notifications with 'MSG: '

  LXC_ATTACH_CMD
    lxc-attach -q --name=$CONTAINER_NAME --lxcpath=LXC_PATH
  LXC_PATH
    first one of: @LXC_PATHS
    where 'LXC_PATH/$CONTAINER_NAME' dir exists
";

my $MODE_SERVICE = "service";
my $MODE_SYSTEMCTL = "systemctl";
my $MODE_INIT = "init";
my $MODE_APP = "app";
my $MODE_SHELL = "shell";
my $MODE_RES = "res";
my $MODE_TAP = "tap";
my $MODE_ORIENT = "orient";
my $MODE_VIEW = "VIEW";
my $MODE_INSTALL = "install";
my $MODE_UNINSTALL = "uninstall";
my $MODE_LAUNCH = "launch";
my $MODE_WAIT = "wait";
my $MODE_CHECK_RUNNING = "check-running";
my $MODE_CHECK_SDCARDS = "check-sdcards";

my $LAUNCH_TYPE_INTENT = "intent";
my $LAUNCH_TYPE_PKG = "pkg";

sub main(@){
  my $mode = undef;
  my $serviceCmd;
  my @cmdArgs;
  my @apkFileArgs;
  my $launchArg = undef;
  my $launchType = undef;
  my $opts = {
    verbose         => 0,
    useNotify       => 0,
    notifyMsg       => undef,
    shellEnvWrapper => 1,
    waitTimeoutS    => undef,
    waitEvents      => [],
  };
  my ($tapXpos, $tapYpos);
  my $orientArg;
  my @mediaFiles;

  while(@_ > 0){
    my $arg = shift @_;
    if($arg =~ /^(-h|--help)$/){
      print $USAGE;
      exit 0;
    }elsif($arg =~ /^(-q|--quiet)$/){
      $$opts{verbose} = 0;
    }elsif($arg =~ /^(-v|--verbose)$/){
      $$opts{verbose} = 1;
    }elsif($arg =~ /^(-n|--notify)$/ and @_ > 0){
      $$opts{useNotify} = 1;
      $$opts{notifyMsg} = shift @_;
    }elsif($arg =~ /^--notify=(.+)$/){
      $$opts{useNotify} = 1;
      $$opts{notifyMsg} = $1;
    }elsif($arg =~ /^--timeout=(\d+)$/){
      $$opts{waitTimeoutS} = $1;
    }elsif($arg =~ /^--events=(.+)$/){
      my $eventCsv = $1;
      $$opts{waitEvents} = [map {lc $_} split(/,/, $eventCsv)];
    }elsif($arg =~ /^--skip-mount$/){
      $$opts{waitEvents} = [$EVENT_ANDROID_START];
    }elsif(not defined $mode and $arg =~ /^(--)?(start)$/){
      $mode = $MODE_SERVICE;
      $serviceCmd = "start";
    }elsif(not defined $mode and $arg =~ /^(--)?(stop)$/){
      $mode = $MODE_SERVICE;
      $serviceCmd = "stop";
    }elsif(not defined $mode and $arg =~ /^(--)?(restart)$/){
      $mode = $MODE_SERVICE;
      $serviceCmd = "restart";
    }elsif(not defined $mode and $arg =~ /^(--)?(systemctl)$/ and @_ >= 1){
      $mode = $MODE_SYSTEMCTL;
      $serviceCmd = shift @_;
    }elsif(not defined $mode and $arg =~ /^(--)?(init)$/){
      $mode = $MODE_INIT;
    }elsif(not defined $mode and $arg =~ /^(--)?(app)$/ and @_ >= 2){
      $mode = $MODE_APP;
      $$opts{useNotify} = 1;
      $$opts{notifyMsg} = shift @_;
      $launchArg = shift @_;
      $launchType = undef;
    }elsif(not defined $mode and $arg =~ /^(-x|x|(--)?(lxc))$/){
      $mode = $MODE_SHELL;
      $$opts{shellEnvWrapper} = 0;
      @cmdArgs = @_;
      @_ = ();
    }elsif(not defined $mode and $arg =~ /^(--)?(shell)$/){
      $mode = $MODE_SHELL;
      $$opts{shellEnvWrapper} = 1;
      @cmdArgs = @_;
      @_ = ();
    }elsif(not defined $mode and $arg =~ /^($SHELL_CMD_FAVORITES_REGEX)$/){
      $mode = $MODE_SHELL;
      $$opts{shellEnvWrapper} = 1;
      @cmdArgs = ($arg, @_);
      @_ = ();
    }elsif(not defined $mode and $arg =~ /^(--)?(fuse|remount-fuse)$/){
      $mode = $MODE_SHELL;
      $$opts{shellEnvWrapper} = 1;
      @cmdArgs = ("mount -a -t fuse -o remount");
    }elsif(not defined $mode and $arg =~ /^(--)?(res)$/){
      $mode = $MODE_RES;
    }elsif(not defined $mode and $arg =~ /^(--)?(tap)$/ and @_ >= 1
           and $_[0] =~ /^(\d+)x(\d+)$/){
      $mode = $MODE_TAP;
      ($tapXpos, $tapYpos) = ($1, $2);
      shift @_;
    }elsif(not defined $mode and $arg =~ /^(--)?(tap)$/ and @_ >= 2
           and $_[0] =~ /^(\d+)$/ and $_[1] =~ /^(\d+)$/){
      $mode = $MODE_TAP;
      $tapXpos = shift @_;
      $tapYpos = shift @_;
    }elsif(not defined $mode and $arg =~ /^(--)?(orient)$/ and @_ >= 1){
      $mode = $MODE_ORIENT;
      $orientArg = shift @_;
    }elsif(not defined $mode and $arg =~ /^(--)?(view)$/){
      $mode = $MODE_VIEW;
      @mediaFiles = (@_);
      @_ = ();
    }elsif(not defined $mode and -f $arg and $arg =~ /\.$OK_MEDIA_EXTS$/i){
      $mode = $MODE_VIEW;
      @mediaFiles = ($arg, @_);
      @_ = ();
    }elsif(not defined $mode and $arg =~ /^(-i|i|(--)?(install))$/){
      $mode = $MODE_INSTALL;
      @apkFileArgs = @_;
      @_ = ();
    }elsif(not defined $mode and $arg =~ /^(-u|u|(--)?(uninstall))$/){
      $mode = $MODE_UNINSTALL;
      @apkFileArgs = @_;
      @_ = ();
    }elsif(not defined $mode and $arg =~ /^(-l|l|(--)?(launch))$/ and @_ >= 1){
      $mode = $MODE_LAUNCH;
      $launchArg = shift @_;
      $launchType = undef;
    }elsif(not defined $mode and $arg =~ /^(--)?(launch-intent)$/ and @_ >= 1){
      $mode = $MODE_LAUNCH;
      $launchArg = shift @_;
      $launchType = $LAUNCH_TYPE_INTENT;
    }elsif(not defined $mode and $arg =~ /^(--)?(launch-pkg)$/ and @_ >= 1){
      $mode = $MODE_LAUNCH;
      $launchArg = shift @_;
      $launchType = $LAUNCH_TYPE_PKG;
    }elsif(not defined $mode and $arg =~ /^(--)?(settings)$/){
      $mode = $MODE_LAUNCH;
      $launchArg = 'com.android.settings/.Settings';
      $launchType = $LAUNCH_TYPE_INTENT;
    }elsif(not defined $mode and $arg =~ /^(-w|w|(--)?(wait))$/ and @_ > 0 and $_[0] =~ /^\d+$/){
      $mode = $MODE_WAIT;
      $$opts{waitTimeoutS} = shift @_;
    }elsif(not defined $mode and $arg =~ /^(-w|w|(--)?(wait))$/){
      $mode = $MODE_WAIT;
    }elsif(not defined $mode and $arg =~ /^(--)?(check-running)$/){
      $mode = $MODE_CHECK_RUNNING;
    }elsif(not defined $mode and $arg =~ /^(--)?(check-sdcards?)$/){
      $mode = $MODE_CHECK_SDCARDS;
    }else{
      die "$USAGE\nERROR: unknown arg '$arg'\n";
    }
  }

  $mode = $MODE_SHELL if not defined $mode;

  $$opts{waitTimeoutS} = $DEFAULT_WAIT_TIMEOUT_SECONDS if not defined $$opts{waitTimeoutS};

  my @apkFiles;
  for my $arg(@apkFileArgs){
    if(-f $arg){
      push @apkFiles, $arg;
    }else{
      my @apkPrefixFiles = getApksForPrefix($arg);
      if(@apkPrefixFiles == 0){
        die "$USAGE\nERROR: no APK files found for prefix $arg\n";
      }
      print "$arg => \n" . join '', map {"  $_\n"} @apkPrefixFiles;
      @apkFiles = (@apkFiles, @apkPrefixFiles);
    }
  }

  if($mode eq $MODE_SERVICE){
    if($serviceCmd eq "start"){
      startDbus();
    }elsif($serviceCmd eq "stop"){
      stopDbus();
    }elsif($serviceCmd eq "restart"){
      restartDbus($opts);
    }else{
      die "ERROR: unknown service cmd $serviceCmd\n";
    }
  }elsif($mode eq $MODE_SYSTEMCTL){
    systemctlCmd($serviceCmd);
  }elsif($mode eq $MODE_INIT){
    initAndroid($opts);
  }elsif($mode eq $MODE_APP){
    initAndroid($opts);
    my $intent = extractLaunchIntent($opts, $launchArg, $launchType);
    launchIntent($intent);
  }elsif($mode eq $MODE_SHELL){
    lxcShell($opts, @cmdArgs);
  }elsif($mode eq $MODE_INSTALL){
    die "$USAGE\nError: no APK_FILE to install\n" if @apkFiles == 0;
    system "sudo", "sh", "-c", "$DBUS_ENV apkd-install-preload -i $CONTAINER_NAME @apkFiles";
    system "sudo", "sh", "-c", "$DBUS_ENV apkd-install -i $CONTAINER_NAME @apkFiles";
  }elsif($mode eq $MODE_UNINSTALL){
    die "$USAGE\nError: no APK_FILE to uninstall\n" if @apkFiles == 0;
    for my $apkFile(@apkFiles){
      my $pkgName = `apk-info --package $apkFile`;
      chomp $pkgName;
      my @cmd = ("pm", "uninstall", $pkgName);
      print "@cmd\n";
      lxcShell $opts, @cmd;
    }
  }elsif($mode eq $MODE_RES){
    my ($screenX, $screenY) = getRes();
    print "${screenX}x${screenY}\n";
  }elsif($mode eq $MODE_TAP){
    my ($screenX, $screenY) = getRes();
    my $isLandscape;
    my ($minDim, $maxDim);
    if(not defined $screenX or not defined $screenY){
      $isLandscape = 0;
      ($minDim, $maxDim) = (undef, undef);
    }else{
      $isLandscape = $screenX > $screenY;
      ($minDim, $maxDim) = $isLandscape ? ($screenY, $screenX) : ($screenX, $screenY);
    }

    my $xPx = parseScreenDimArg($tapXpos, $minDim);
    my $yPx = parseScreenDimArg($tapYpos, $maxDim);

    my $realX = $isLandscape ? $yPx : $xPx;
    my $realY = $isLandscape ? $screenY - $xPx : $yPx;

    print "tapping ${realX}x${realY}\n";
    lxcShell $opts, "input", "tap", $realX, $realY;
  }elsif($mode eq $MODE_ORIENT){
    my ($accelVal, $userVal);
    if($orientArg =~ /^(dynamic|auto|none|d|a|n)$/){
      ($accelVal, $userVal) = (1, 0);
    }elsif($orientArg =~ /^(portrait|p|0)$/){
      ($accelVal, $userVal) = (0, 0);
    }elsif($orientArg =~ /^(landscape|l|1)$/){
      ($accelVal, $userVal) = (0, 1);
    }elsif($orientArg =~ /^(portrait-inverted|pi|2)$/){
      ($accelVal, $userVal) = (0, 2);
    }elsif($orientArg =~ /^(landscape-inverted|li|3)$/){
      ($accelVal, $userVal) = (0, 3);
    }

    lxcShell $opts, ("settings", "put", "system", "accelerometer_rotation", "$accelVal");
    lxcShell $opts, ("settings", "put", "system", "user_rotation", "$userVal");

    #twice because sometimes inverted is ignored the first time
    lxcShell $opts, ("settings", "put", "system", "accelerometer_rotation", "$accelVal");
    lxcShell $opts, ("settings", "put", "system", "user_rotation", "$userVal");
  }elsif($mode eq $MODE_VIEW){
    for my $file(@mediaFiles){
      my $mimeType = `file -b --mime-type "$file"`;
      chomp $mimeType;

      my $androidFile = abs_path $file;
      $androidFile =~ s/^(\/run\/media\/\w+\/[^\/]+\/)/\/sdcard\/SDCARD\//;
      $androidFile =~ s/^(\/home\/\w+\/android_storage\/)/\/sdcard\//;
      print "\n\n$androidFile\n\n";
      my @cmd = (
        "am",
        "start",
        "-a", "android.intent.action.VIEW",
        "-d", "file://$androidFile",
        "-t", "$mimeType",
      );
      print "\n@cmd\n";
      lxcShell $opts, @cmd;
    }
  }elsif($mode eq $MODE_LAUNCH){
    my $intent = extractLaunchIntent($opts, $launchArg, $launchType);
    launchIntent($intent);
  }elsif($mode eq $MODE_WAIT){
    my @waitEvents = @{$$opts{waitEvents}};
    if(waitForAndroidEvents($opts, @waitEvents)){
      exit 0;
    }else{
      printf STDERR "ERROR: aliendalvik did not start and mount sdcards+home in %ds\n",
        $$opts{waitTimeoutS};
      exit 1;
    }
  }elsif($mode eq $MODE_CHECK_RUNNING){
    if(isAliendalvikRunning($opts)){
      exit 0;
    }else{
      print STDERR "ERROR: aliendalvik is not running\n";
      exit 1;
    }
  }elsif($mode eq $MODE_CHECK_SDCARDS){
    my $sdcardsConf = readSdcardsConf();
    if(isSdcardsMounted($opts, $sdcardsConf) && isHomeMounted($opts)){
      exit 0;
    }else{
      print STDERR "ERROR: sdcards+home are not mounted\n";
      exit 1;
    }
  }else{
    die "ERROR: unknown mode $mode\n";
  }
}

sub initAndroid($){
  my ($opts) = @_;
  my $attempts = 2;
  my @waitEvents = @{$$opts{waitEvents}};
  while(1){
    $attempts--;
    die "ERROR: android failed to start and mount sdcards+home\n" if $attempts < 0;

    if(not isAliendalvikRunning($opts)){
      startDbus();
    }
    if(waitForAndroidEvents($opts, @waitEvents)){
      last;
    }
  }
}

sub startDbus(){
  sendDbusStartStop(1);
}
sub stopDbus(){
  sendDbusStartStop(0);
}
sub restartDbus($){
  my ($opts) = @_;
  sendDbusStartStop(0);
  my @waitEvents = ($EVENT_ANDROID_STOP);
  waitForAndroidEvents($opts, @waitEvents);
  sleep 3;
  sendDbusStartStop(1);
}

sub sendDbusStartStop($){
  my ($isStart) = @_;

  my @dbusCmd = ("dbus-send",
    "--system",
    "--type=method_call",
    "--print-reply",
    "--dest=$DBUS_DEST_SERVICE_NAME",
    "$DBUS_PATH",
    "$DBUS_CONTROL_METHOD",
    ($isStart ? "boolean:true" : "boolean:false"),
    "string:$USER",
  );

  system @dbusCmd;
}

sub systemctlCmd($){
  my ($serviceCmd) = @_;
  if($ENV{USER} eq $USER){
    system "$DBUS_ENV systemctl --user $serviceCmd $SYSTEMD_SERVICE";
  }elsif($ENV{USER} eq "root"){
    system "runuser -l $USER -c '$DBUS_ENV systemctl --user $serviceCmd $SYSTEMD_SERVICE'";
  }else{
    die "ERROR: user '$ENV{USER}' must be $USER or root\n";
  }
}

sub waitForAndroidEvents($@){
  my ($opts, @events) = @_;

  @events = ($EVENT_ANDROID_START, $EVENT_ANDROID_MOUNT) if @events == 0;

  for my $event(@events){
    if($event !~ /^($EVENT_ANDROID_START|$EVENT_ANDROID_STOP|$EVENT_ANDROID_MOUNT)$/){
      die "ERROR: unknown event '$event'\n";
    }
  }

  my $waitTimeoutS = defined $$opts{waitTimeoutS} ?
    $$opts{waitTimeoutS} : $DEFAULT_WAIT_TIMEOUT_SECONDS;
  my $waitTimeoutMillis = $waitTimeoutS * 1000;
  my $start = nowMillis();
  my $sdcardsConf = readSdcardsConf();
  my $notifiedWaiting = 0;
  my $notifyPrefix = defined $$opts{notifyMsg} ? $$opts{notifyMsg} : "ad";

  my $msg = "$notifyPrefix: android " . join("+", @events);

  while(1){
    if($waitTimeoutMillis < nowMillis()-$start){
      if($$opts{useNotify}){
        system "notify", "$msg TIMEOUT";
      }
      return 0;
    }

    my $isSuccess = 1;
    for my $event(@events){
      if($event eq $EVENT_ANDROID_START){
        $isSuccess = isAliendalvikRunning($opts);
      }elsif($event eq $EVENT_ANDROID_STOP){
        $isSuccess = not isAliendalvikRunning($opts);
      }elsif($event eq $EVENT_ANDROID_MOUNT){
        $isSuccess = isSdcardsMounted($opts, $sdcardsConf) && isHomeMounted($opts);
      }else{
        die "ERROR: unknown event $event\n";
      }
      last if not $isSuccess;
    }

    if($isSuccess){
      if($$opts{useNotify} and $notifiedWaiting){
        system "notify", "$msg SUCCESS";
      }
      return 1;
    }else{
      if($$opts{useNotify} and not $notifiedWaiting){
        system "notify", "$msg WAITING";
        $notifiedWaiting = 1;
      }
    }
    sleep 1;
  }
}

sub isAliendalvikRunning($){
  my ($opts) = @_;
  my $out = lxcReadProc $opts, "echo", "ok";
  if($out =~ /^ok$/){
    return 1;
  }else{
    return 0;
  }
}

sub launchIntent($){
  my ($intent) = @_;
  my ($pkgName, $activity);
  if($intent =~ /^(.+)\/(.+)$/){
    ($pkgName, $activity) = ($1, $2);
    if($activity =~ /^\./){
      #this is NOT implemented by apkd-launcher, apparently
      $activity = "$pkgName$activity";
    }
  }else{
    die "ERROR: malformed intent (must be PKG_NAME/ACTIVITY)\n";
  }
  my $apk = "$pkgName.apk";
  my @cmd = ("apkd-launcher", $apk, "$pkgName/$activity");
  exec @cmd;
}

sub extractLaunchIntent($$$){
  my ($opts, $launchArg, $launchType) = @_;
  if(not defined $launchType){
    if($launchArg =~ /^\w+\.(\w+\.)+\w+\/(.*)$/){
      $launchType = $LAUNCH_TYPE_INTENT;
    }elsif($launchArg =~ /^\w+\.(\w+\.)+\w+$/){
      $launchType = $LAUNCH_TYPE_PKG;
    }
  }

  if(not defined $launchType){
    die "ERROR: could not infer launch type from $launchArg\n";
  }

  my $intent;
  if($launchType eq $LAUNCH_TYPE_INTENT){
    $intent = $launchArg;
  }elsif($launchType eq $LAUNCH_TYPE_PKG){
    $intent = readIntentFromPkgName($opts, $launchArg);
  }else{
    die "ERROR: unknown LAUNCH_TYPE $launchType\n";
  }

  return $intent;
}

sub readIntentFromPkgName($$){
  my ($opts, $pkgName) = @_;
  my $out = lxcReadProc($opts, "cmd", "package", "resolve-activity", "--brief", $pkgName);
  if($out =~ /^($pkgName\/.+)$/m){
    return $1;
  }else{
    die "ERROR: could not read main activity of pkg $pkgName\n";
  }
}

sub readSdcardsConf(){
  my $entries = {};
  if(-e $SDCARDS_CONF_FILE){
    open my $fh, "<", $SDCARDS_CONF_FILE
      or die "ERROR: could not read $SDCARDS_CONF_FILE\n$!\n";
    my @lines = <$fh>;
    close $fh;
    for my $line(@lines){
      if($line =~ /^\s*(\w+)\.(\w+)\s*=\s*(.*)?\s*$/){
        my ($name, $field, $val) = ($1, $2, $3);
        $$entries{$name} = {} if not defined $$entries{$name};
        $$entries{$name}{$field} = $val;
      }
    }
  }
  return $entries;
}

sub isSdcardsMounted($$){
  my ($opts, $sdcardsConf) = @_;
  for my $name(sort keys %$sdcardsConf){
    my $isAndroid = $$sdcardsConf{$name}{android};
    $isAndroid = "" if not defined $isAndroid;
    if($isAndroid =~ /true/i){
      my $uuid = $$sdcardsConf{$name}{uuid};
      if(not defined $uuid){
        die "ERROR: failed to parse UUID in $SDCARDS_CONF_FILE\n";
      }
      if(not isUUIDMounted($opts, $uuid)){
        print "sdcard '$name' is not mounted\n";
        return 0;
      }
    }
  }
  return 1;
}

sub isUUIDMounted($$){
  my ($opts, $uuid) = @_;
  my $dir = "/storage/$uuid";
  my $out = lxcReadProc $opts, "mountpoint", $dir;
  if($out =~ /^$dir is a mountpoint$/){
    return 1;
  }else{
    return 0;
  }
}

sub isHomeMounted($){
  my ($opts) = @_;
  my $out = lxcReadProc $opts, "mount";

  my $homeUUID;
  my $uuidRegex = "[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}";
  if($out =~ /^$SAILFISH_HOME_MAPPER_BLOCK_DEV on \S+\/($uuidRegex)/m){
    $homeUUID = $1;
  }

  if(defined $homeUUID and $out =~ / on \/storage\/$homeUUID/){
    return 1;
  }else{
    return 0;
  }
}

sub lxcWrapCmd($@){
  my ($opts, @shellCmd) = @_;
  my $lxcPath;
  for my $dir(@LXC_PATHS){
    if(-d "$dir/$CONTAINER_NAME"){
      $lxcPath = $dir;
    }
  }

  my @cmd = ("sudo", "lxc-attach", "-q", "--name=$CONTAINER_NAME", "--lxcpath=$lxcPath");

  if(@shellCmd > 0){
    if($$opts{shellEnvWrapper}){
      @cmd = (@cmd, "--", "sh", "-c", "$SHELL_ENV_VARS_SH_FMT @shellCmd");
    }else{
      @cmd = (@cmd, "--", @shellCmd);
    }
  }

  return @cmd;
}

sub lxcShell($@){
  my ($opts, @shellCmd) = @_;
  my @cmd = lxcWrapCmd($opts, @shellCmd);
  print "@cmd\n" if $$opts{verbose};
  system @cmd;
}

sub lxcReadProc($@){
  my ($opts, @shellCmd) = @_;
  my @cmd = lxcWrapCmd($opts, @shellCmd);
  open my $fh, "-|", @cmd or die "ERROR: could not run cmd @cmd\n$!\n";
  my $output = join '', <$fh>;
  close $fh;
  return $output;
}

sub getApksForPrefix($){
  my ($prefix) = @_;
  my @files = glob "$APK_DIR/$prefix*";
  @files = grep {/\.apk$/i} grep {-f $_} @files;
  return @files;
}

sub getRes(){
  my $out = `$EXEC --shell dumpsys window`;
  if($out =~ /DisplayInfo.*real (\d+) x (\d+)/){
    return ($1, $2);
  }
  return (undef, undef);
}

sub parseScreenDimArg($$){
  my ($arg, $screenDimSize) = @_;
  if($arg =~ /^(\d+)$/){
    return $1;
  }elsif($arg =~ /^(\d+|\d*\.\d+)%$/){
    die "ERROR: missing screen dimension\n" if not defined $screenDimSize;
    return int($1/100.0*$screenDimSize + 0.5);
  }
}

sub nowMillis(){
  return int(time * 1000.0 + 0.5);
}

&main(@ARGV);
